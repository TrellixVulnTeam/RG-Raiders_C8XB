{"ast":null,"code":"import _slicedToArray from \"/Users/mark.wagner/Dropbox/projects/TheGame/node_modules/next/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\nvar _s = $RefreshSig$();\n\nimport { useEffect, useState } from 'react';\nexport var useIsSticky = function useIsSticky(ref) {\n  _s();\n\n  var _useState = useState(false),\n      isSticky = _useState[0],\n      setIsSticky = _useState[1];\n\n  useEffect(function () {\n    var observer = new IntersectionObserver(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 1),\n          entry = _ref2[0];\n\n      return setIsSticky(entry.intersectionRatio < 1);\n    }, {\n      threshold: [1]\n    });\n\n    if (ref.current) {\n      observer.observe(ref.current);\n    }\n\n    return function () {\n      observer.disconnect();\n    };\n  }, [ref]);\n  return isSticky;\n};\n\n_s(useIsSticky, \"i8qBv7+w1xo/aojUVt4YquRar/k=\");","map":{"version":3,"sources":["/Users/mark.wagner/Dropbox/projects/TheGame/packages/web/lib/hooks/useIsSticky.tsx"],"names":["useEffect","useState","useIsSticky","ref","isSticky","setIsSticky","observer","IntersectionObserver","entry","intersectionRatio","threshold","current","observe","disconnect"],"mappings":";;;;AAAA,SAAoBA,SAApB,EAA+BC,QAA/B,QAA+C,OAA/C;AAEA,OAAO,IAAMC,WAAW,GAAG,SAAdA,WAAc,CAACC,GAAD,EAA6C;AAAA;;AAAA,kBACtCF,QAAQ,CAAC,KAAD,CAD8B;AAAA,MAC/DG,QAD+D;AAAA,MACrDC,WADqD;;AAGtEL,EAAAA,SAAS,CAAC,YAAM;AACd,QAAMM,QAAQ,GAAG,IAAIC,oBAAJ,CACf;AAAA;AAAA,UAAEC,KAAF;;AAAA,aAAaH,WAAW,CAACG,KAAK,CAACC,iBAAN,GAA0B,CAA3B,CAAxB;AAAA,KADe,EAEf;AAAEC,MAAAA,SAAS,EAAE,CAAC,CAAD;AAAb,KAFe,CAAjB;;AAIA,QAAIP,GAAG,CAACQ,OAAR,EAAiB;AACfL,MAAAA,QAAQ,CAACM,OAAT,CAAiBT,GAAG,CAACQ,OAArB;AACD;;AACD,WAAO,YAAM;AACXL,MAAAA,QAAQ,CAACO,UAAT;AACD,KAFD;AAGD,GAXQ,EAWN,CAACV,GAAD,CAXM,CAAT;AAaA,SAAOC,QAAP;AACD,CAjBM;;GAAMF,W","sourcesContent":["import { RefObject, useEffect, useState } from 'react';\n\nexport const useIsSticky = (ref: RefObject<HTMLDivElement>): boolean => {\n  const [isSticky, setIsSticky] = useState(false);\n\n  useEffect(() => {\n    const observer = new IntersectionObserver(\n      ([entry]) => setIsSticky(entry.intersectionRatio < 1),\n      { threshold: [1] },\n    );\n    if (ref.current) {\n      observer.observe(ref.current);\n    }\n    return () => {\n      observer.disconnect();\n    };\n  }, [ref]);\n\n  return isSticky;\n};\n"]},"metadata":{},"sourceType":"module"}