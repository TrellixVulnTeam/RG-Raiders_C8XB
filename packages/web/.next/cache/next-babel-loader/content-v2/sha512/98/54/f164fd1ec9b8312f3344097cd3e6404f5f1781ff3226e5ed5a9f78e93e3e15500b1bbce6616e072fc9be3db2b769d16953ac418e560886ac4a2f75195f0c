{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport { retryExchange } from '@urql/exchange-retry';\nimport { initUrqlClient, withUrqlClient } from 'next-urql';\nimport { createElement } from 'react';\nimport { cacheExchange, createClient, dedupExchange, fetchExchange, ssrExchange } from 'urql';\nimport { CONFIG } from '../config';\nimport { getTokenFromStore } from '../lib/auth';\n\nconst errorHasResponseTimeout = err => err.graphQLErrors.length > 0 && !!err.graphQLErrors.find(_err => _err.message === 'ResponseTimeout');\n\nconst retryExchangeFunc = retryExchange({\n  retryIf: error => !!(errorHasResponseTimeout(error) || error.networkError)\n});\nexport const client = createClient({\n  url: CONFIG.graphqlURL,\n  suspense: false,\n  exchanges: [dedupExchange, cacheExchange, retryExchangeFunc, fetchExchange]\n});\nexport const getSsrClient = () => {\n  const ssrCache = ssrExchange({\n    isClient: false\n  });\n  const ssrClient = initUrqlClient({\n    url: CONFIG.graphqlURL,\n    exchanges: [dedupExchange, cacheExchange, ssrCache, retryExchangeFunc, fetchExchange]\n  }, false);\n  if (!ssrClient) throw new Error('wtf');\n  return [ssrClient, ssrCache];\n}; // We do this to enable ssr cache on pages that are not directly wrapped in 'withUrqlClient' (but on _app)\n// https://github.com/FormidableLabs/urql/issues/1481\n\nconst customWithUrqlClient = WithUrql => (_ref) => {\n  let {\n    pageProps,\n    urqlState\n  } = _ref,\n      props = _objectWithoutProperties(_ref, [\"pageProps\", \"urqlState\"]);\n\n  return /*#__PURE__*/createElement(WithUrql, _objectSpread({\n    urqlState: pageProps.urqlState || urqlState,\n    pageProps\n  }, props));\n};\n\nexport const wrapUrqlClient = AppOrPage => customWithUrqlClient(withUrqlClient((_ssrExchange, ctx) => ({\n  url: CONFIG.graphqlURL,\n  fetchOptions: () => {\n    var _ctx$req, _ctx$req$headers;\n\n    const token = ctx ? ctx === null || ctx === void 0 ? void 0 : (_ctx$req = ctx.req) === null || _ctx$req === void 0 ? void 0 : (_ctx$req$headers = _ctx$req.headers) === null || _ctx$req$headers === void 0 ? void 0 : _ctx$req$headers.authorization : getTokenFromStore();\n    return {\n      headers: {\n        Authorization: token ? `Bearer ${token}` : ''\n      }\n    };\n  }\n}), {\n  neverSuspend: true,\n  ssr: false\n})(AppOrPage));","map":{"version":3,"sources":["/Users/mark.wagner/Dropbox/projects/TheGame/packages/web/graphql/client.ts"],"names":["retryExchange","initUrqlClient","withUrqlClient","createElement","cacheExchange","createClient","dedupExchange","fetchExchange","ssrExchange","CONFIG","getTokenFromStore","errorHasResponseTimeout","err","graphQLErrors","length","find","_err","message","retryExchangeFunc","retryIf","error","networkError","client","url","graphqlURL","suspense","exchanges","getSsrClient","ssrCache","isClient","ssrClient","Error","customWithUrqlClient","WithUrql","pageProps","urqlState","props","wrapUrqlClient","AppOrPage","_ssrExchange","ctx","fetchOptions","token","req","headers","authorization","Authorization","neverSuspend","ssr"],"mappings":";;;;;;;;;;AAAA,SAASA,aAAT,QAA8B,sBAA9B;AACA,SACEC,cADF,EAGEC,cAHF,QAKO,WALP;AAMA,SAAgBC,aAAhB,QAAqC,OAArC;AACA,SACEC,aADF,EAIEC,YAJF,EAKEC,aALF,EAMEC,aANF,EAOEC,WAPF,QAQO,MARP;AAUA,SAASC,MAAT,QAAuB,WAAvB;AACA,SAASC,iBAAT,QAAkC,aAAlC;;AAEA,MAAMC,uBAAuB,GAAIC,GAAD,IAC9BA,GAAG,CAACC,aAAJ,CAAkBC,MAAlB,GAA2B,CAA3B,IACA,CAAC,CAACF,GAAG,CAACC,aAAJ,CAAkBE,IAAlB,CAAwBC,IAAD,IAAUA,IAAI,CAACC,OAAL,KAAiB,iBAAlD,CAFJ;;AAIA,MAAMC,iBAAiB,GAAGlB,aAAa,CAAC;AACtCmB,EAAAA,OAAO,EAAGC,KAAD,IAAW,CAAC,EAAET,uBAAuB,CAACS,KAAD,CAAvB,IAAkCA,KAAK,CAACC,YAA1C;AADiB,CAAD,CAAvC;AAIA,OAAO,MAAMC,MAAM,GAAGjB,YAAY,CAAC;AACjCkB,EAAAA,GAAG,EAAEd,MAAM,CAACe,UADqB;AAEjCC,EAAAA,QAAQ,EAAE,KAFuB;AAGjCC,EAAAA,SAAS,EAAE,CAACpB,aAAD,EAAgBF,aAAhB,EAA+Bc,iBAA/B,EAAkDX,aAAlD;AAHsB,CAAD,CAA3B;AAMP,OAAO,MAAMoB,YAAY,GAAG,MAAgD;AAC1E,QAAMC,QAAQ,GAAGpB,WAAW,CAAC;AAAEqB,IAAAA,QAAQ,EAAE;AAAZ,GAAD,CAA5B;AAEA,QAAMC,SAAS,GAAG7B,cAAc,CAC9B;AACEsB,IAAAA,GAAG,EAAEd,MAAM,CAACe,UADd;AAEEE,IAAAA,SAAS,EAAE,CACTpB,aADS,EAETF,aAFS,EAGTwB,QAHS,EAITV,iBAJS,EAKTX,aALS;AAFb,GAD8B,EAW9B,KAX8B,CAAhC;AAaA,MAAI,CAACuB,SAAL,EAAgB,MAAM,IAAIC,KAAJ,CAAU,KAAV,CAAN;AAEhB,SAAO,CAACD,SAAD,EAAYF,QAAZ,CAAP;AACD,CAnBM,C,CAqBP;AACA;;AACA,MAAMI,oBAAoB,GACxBC,QAD2B,IAEC;AAAA,MAAC;AAAEC,IAAAA,SAAF;AAAaC,IAAAA;AAAb,GAAD;AAAA,MAA4BC,KAA5B;;AAAA,sBAC5BjC,aAAa,CAAC8B,QAAD;AACXE,IAAAA,SAAS,EAAED,SAAS,CAACC,SAAV,IAAuBA,SADvB;AAEXD,IAAAA;AAFW,KAGRE,KAHQ,EADe;AAAA,CAF9B;;AASA,OAAO,MAAMC,cAAc,GAAIC,SAAD,IAC5BN,oBAAoB,CAClB9B,cAAc,CACZ,CAACqC,YAAD,EAAeC,GAAf,MAAwB;AACtBjB,EAAAA,GAAG,EAAEd,MAAM,CAACe,UADU;AAEtBiB,EAAAA,YAAY,EAAE,MAAM;AAAA;;AAClB,UAAMC,KAAK,GAAGF,GAAG,GACbA,GADa,aACbA,GADa,mCACbA,GAAG,CAAEG,GADQ,iEACb,SAAUC,OADG,qDACb,iBAAmBC,aADN,GAEbnC,iBAAiB,EAFrB;AAGA,WAAO;AACLkC,MAAAA,OAAO,EAAE;AACPE,QAAAA,aAAa,EAAEJ,KAAK,GAAI,UAASA,KAAM,EAAnB,GAAuB;AADpC;AADJ,KAAP;AAKD;AAXqB,CAAxB,CADY,EAcZ;AACEK,EAAAA,YAAY,EAAE,IADhB;AAEEC,EAAAA,GAAG,EAAE;AAFP,CAdY,CAAd,CAkBEV,SAlBF,CADkB,CADf","sourcesContent":["import { retryExchange } from '@urql/exchange-retry';\nimport {\n  initUrqlClient,\n  NextComponentType,\n  withUrqlClient,\n  WithUrqlProps,\n} from 'next-urql';\nimport React, { createElement } from 'react';\nimport {\n  cacheExchange,\n  Client,\n  CombinedError,\n  createClient,\n  dedupExchange,\n  fetchExchange,\n  ssrExchange,\n} from 'urql';\n\nimport { CONFIG } from '../config';\nimport { getTokenFromStore } from '../lib/auth';\n\nconst errorHasResponseTimeout = (err: CombinedError): boolean =>\n  err.graphQLErrors.length > 0 &&\n  !!err.graphQLErrors.find((_err) => _err.message === 'ResponseTimeout');\n\nconst retryExchangeFunc = retryExchange({\n  retryIf: (error) => !!(errorHasResponseTimeout(error) || error.networkError),\n});\n\nexport const client = createClient({\n  url: CONFIG.graphqlURL,\n  suspense: false,\n  exchanges: [dedupExchange, cacheExchange, retryExchangeFunc, fetchExchange],\n});\n\nexport const getSsrClient = (): [Client, ReturnType<typeof ssrExchange>] => {\n  const ssrCache = ssrExchange({ isClient: false });\n\n  const ssrClient = initUrqlClient(\n    {\n      url: CONFIG.graphqlURL,\n      exchanges: [\n        dedupExchange,\n        cacheExchange,\n        ssrCache,\n        retryExchangeFunc,\n        fetchExchange,\n      ],\n    },\n    false,\n  );\n  if (!ssrClient) throw new Error('wtf');\n\n  return [ssrClient, ssrCache];\n};\n\n// We do this to enable ssr cache on pages that are not directly wrapped in 'withUrqlClient' (but on _app)\n// https://github.com/FormidableLabs/urql/issues/1481\nconst customWithUrqlClient = (\n  WithUrql: NextComponentType,\n): React.FC<WithUrqlProps> => ({ pageProps, urqlState, ...props }) =>\n  createElement(WithUrql, {\n    urqlState: pageProps.urqlState || urqlState,\n    pageProps,\n    ...props,\n  });\n\nexport const wrapUrqlClient = (AppOrPage: React.FC<WithUrqlProps>) =>\n  customWithUrqlClient(\n    withUrqlClient(\n      (_ssrExchange, ctx) => ({\n        url: CONFIG.graphqlURL,\n        fetchOptions: () => {\n          const token = ctx\n            ? ctx?.req?.headers?.authorization\n            : getTokenFromStore();\n          return {\n            headers: {\n              Authorization: token ? `Bearer ${token}` : '',\n            },\n          };\n        },\n      }),\n      {\n        neverSuspend: true,\n        ssr: false,\n      },\n    )(AppOrPage),\n  );\n"]},"metadata":{},"sourceType":"module"}