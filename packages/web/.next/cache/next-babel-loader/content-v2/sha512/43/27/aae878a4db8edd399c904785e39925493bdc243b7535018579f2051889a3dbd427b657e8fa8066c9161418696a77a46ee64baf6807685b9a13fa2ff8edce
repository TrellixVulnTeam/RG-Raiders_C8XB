{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nexport const parseSkills = skills => {\n  const skillsMap = {};\n  skills.forEach(skill => {\n    var _skillsMap$skill$cate;\n\n    if (!(skill.category in skillsMap)) {\n      skillsMap[skill.category] = {\n        label: skill.category,\n        options: []\n      };\n    }\n\n    (_skillsMap$skill$cate = skillsMap[skill.category].options) === null || _skillsMap$skill$cate === void 0 ? void 0 : _skillsMap$skill$cate.push(_objectSpread({\n      value: skill.id,\n      label: skill.name\n    }, skill));\n  });\n  return Object.values(skillsMap);\n};","map":{"version":3,"sources":["/Users/mark.wagner/Dropbox/projects/TheGame/packages/web/utils/skillHelpers.ts"],"names":["parseSkills","skills","skillsMap","forEach","skill","category","label","options","push","value","id","name","Object","values"],"mappings":";;;;;;AAgBA,OAAO,MAAMA,WAAW,GACtBC,MADyB,IAEC;AAC1B,QAAMC,SAAmB,GAAG,EAA5B;AACAD,EAAAA,MAAM,CAACE,OAAP,CAAgBC,KAAD,IAAW;AAAA;;AACxB,QAAI,EAAEA,KAAK,CAACC,QAAN,IAAkBH,SAApB,CAAJ,EAAoC;AAClCA,MAAAA,SAAS,CAACE,KAAK,CAACC,QAAP,CAAT,GAA4B;AAC1BC,QAAAA,KAAK,EAAEF,KAAK,CAACC,QADa;AAE1BE,QAAAA,OAAO,EAAE;AAFiB,OAA5B;AAID;;AACD,6BAAAL,SAAS,CAACE,KAAK,CAACC,QAAP,CAAT,CAA0BE,OAA1B,gFAAmCC,IAAnC;AACEC,MAAAA,KAAK,EAAEL,KAAK,CAACM,EADf;AAEEJ,MAAAA,KAAK,EAAEF,KAAK,CAACO;AAFf,OAGKP,KAHL;AAKD,GAZD;AAaA,SAAOQ,MAAM,CAACC,MAAP,CAAcX,SAAd,CAAP;AACD,CAlBM","sourcesContent":["import { PlayerSkillFragmentFragment } from '../graphql/autogen/types';\n\nexport type SkillMap = {\n  [category: string]: CategoryOption;\n};\n\nexport type SkillOption = PlayerSkillFragmentFragment & {\n  value: string;\n  label: string;\n};\n\nexport type CategoryOption = {\n  label: string;\n  options: Array<SkillOption>;\n};\n\nexport const parseSkills = (\n  skills: Array<PlayerSkillFragmentFragment>,\n): Array<CategoryOption> => {\n  const skillsMap: SkillMap = {};\n  skills.forEach((skill) => {\n    if (!(skill.category in skillsMap)) {\n      skillsMap[skill.category] = {\n        label: skill.category,\n        options: [],\n      };\n    }\n    skillsMap[skill.category].options?.push({\n      value: skill.id,\n      label: skill.name,\n      ...skill,\n    });\n  });\n  return Object.values(skillsMap);\n};\n\nexport type TimeZoneOption = {\n  value: string;\n  label: string;\n};\n"]},"metadata":{},"sourceType":"module"}