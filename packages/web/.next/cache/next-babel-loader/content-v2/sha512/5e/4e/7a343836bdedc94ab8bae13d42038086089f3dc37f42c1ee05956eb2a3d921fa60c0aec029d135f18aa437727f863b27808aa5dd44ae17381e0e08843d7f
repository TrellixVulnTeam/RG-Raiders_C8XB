{"ast":null,"code":"import _slicedToArray from \"/Users/mark.wagner/Dropbox/projects/TheGame/node_modules/next/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\nvar _s = $RefreshSig$();\n\nimport { useEffect, useState } from 'react';\nexport var useOnScreen = function useOnScreen(ref) {\n  _s();\n\n  var _useState = useState(false),\n      isIntersecting = _useState[0],\n      setIntersecting = _useState[1];\n\n  useEffect(function () {\n    var observer = new IntersectionObserver(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 1),\n          entry = _ref2[0];\n\n      return setIntersecting(entry.isIntersecting);\n    });\n\n    if (ref.current) {\n      observer.observe(ref.current);\n    }\n\n    return function () {\n      observer.disconnect();\n    };\n  }, [ref]);\n  return isIntersecting;\n};\n\n_s(useOnScreen, \"+TWZGT8mxcpNH+JS7IkSFv1hR0A=\");","map":{"version":3,"sources":["/Users/mark.wagner/Dropbox/projects/TheGame/packages/web/lib/hooks/useOnScreen.tsx"],"names":["useEffect","useState","useOnScreen","ref","isIntersecting","setIntersecting","observer","IntersectionObserver","entry","current","observe","disconnect"],"mappings":";;;;AAAA,SAAoBA,SAApB,EAA+BC,QAA/B,QAA+C,OAA/C;AAEA,OAAO,IAAMC,WAAW,GAAG,SAAdA,WAAc,CAACC,GAAD,EAA6C;AAAA;;AAAA,kBAC5BF,QAAQ,CAAC,KAAD,CADoB;AAAA,MAC/DG,cAD+D;AAAA,MAC/CC,eAD+C;;AAGtEL,EAAAA,SAAS,CAAC,YAAM;AACd,QAAMM,QAAQ,GAAG,IAAIC,oBAAJ,CAAyB;AAAA;AAAA,UAAEC,KAAF;;AAAA,aACxCH,eAAe,CAACG,KAAK,CAACJ,cAAP,CADyB;AAAA,KAAzB,CAAjB;;AAGA,QAAID,GAAG,CAACM,OAAR,EAAiB;AACfH,MAAAA,QAAQ,CAACI,OAAT,CAAiBP,GAAG,CAACM,OAArB;AACD;;AACD,WAAO,YAAM;AACXH,MAAAA,QAAQ,CAACK,UAAT;AACD,KAFD;AAGD,GAVQ,EAUN,CAACR,GAAD,CAVM,CAAT;AAYA,SAAOC,cAAP;AACD,CAhBM;;GAAMF,W","sourcesContent":["import { RefObject, useEffect, useState } from 'react';\n\nexport const useOnScreen = (ref: RefObject<HTMLDivElement>): boolean => {\n  const [isIntersecting, setIntersecting] = useState(false);\n\n  useEffect(() => {\n    const observer = new IntersectionObserver(([entry]) =>\n      setIntersecting(entry.isIntersecting),\n    );\n    if (ref.current) {\n      observer.observe(ref.current);\n    }\n    return () => {\n      observer.disconnect();\n    };\n  }, [ref]);\n\n  return isIntersecting;\n};\n"]},"metadata":{},"sourceType":"module"}