{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { useGetPlayerFiltersQuery, useGetPlayersQuery } from 'graphql/autogen/types';\nimport { defaultQueryVariables, PLAYER_LIMIT } from 'graphql/getPlayers';\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { parseSkills } from 'utils/skillHelpers'; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nconst usePlayerAggregates = () => {\n  const [{\n    data\n  }] = useGetPlayerFiltersQuery();\n  const skillChoices = useMemo(() => parseSkills((data === null || data === void 0 ? void 0 : data.skill) || []), [data]);\n  return {\n    skillCategories: (data === null || data === void 0 ? void 0 : data.skill_aggregate.nodes) || [],\n    playerTypes: ((data === null || data === void 0 ? void 0 : data.player_type) || []).map(({\n      value,\n      label\n    }) => ({\n      value: value.toString(),\n      label\n    })),\n    skillChoices\n  };\n};\n\nconst useFilteredPlayers = queryVariables => {\n  var _data$player_aggregat;\n\n  const {\n    0: variables,\n    1: setVariables\n  } = useState(defaultQueryVariables);\n  useEffect(() => {\n    setVariables(queryVariables);\n  }, [queryVariables]);\n  const [{\n    fetching,\n    data,\n    error\n  }] = useGetPlayersQuery({\n    variables\n  });\n  const players = (data === null || data === void 0 ? void 0 : data.player) || [];\n  const totalCount = (data === null || data === void 0 ? void 0 : (_data$player_aggregat = data.player_aggregate.aggregate) === null || _data$player_aggregat === void 0 ? void 0 : _data$player_aggregat.count) || 0;\n  return {\n    fetching,\n    players,\n    totalCount,\n    error\n  };\n};\n\nexport const usePlayerFilter = (defaultVariables = defaultQueryVariables) => {\n  const {\n    0: queryVariables,\n    1: setQueryVariables\n  } = useState(defaultVariables);\n  const aggregates = usePlayerAggregates();\n  const shouldAppend = useRef(false);\n  const setQueryVariable = useCallback( // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  (key, value) => {\n    if (key === 'limit') {\n      throw new Error('Cannot update limit');\n    }\n\n    setQueryVariables(oldQueryVariables => _objectSpread(_objectSpread({}, oldQueryVariables), {}, {\n      limit: PLAYER_LIMIT,\n      offset: 0,\n      [key]: value !== '' ? value : null\n    }));\n    shouldAppend.current = key === 'offset';\n  }, []);\n\n  const resetFilter = () => setQueryVariables(defaultQueryVariables);\n\n  const {\n    fetchedPlayers,\n    fetching,\n    error,\n    nextPage,\n    totalCount,\n    moreAvailable\n  } = usePaginatedPlayers(queryVariables, setQueryVariable);\n  const {\n    0: players,\n    1: setPlayers\n  } = useState(fetchedPlayers);\n  useEffect(() => {\n    if (error || fetching) {\n      if (error || !shouldAppend.current) {\n        setPlayers([]);\n      }\n    } else if (shouldAppend.current) {\n      setPlayers(p => [...p, ...fetchedPlayers]);\n      shouldAppend.current = false;\n    } else {\n      setPlayers(fetchedPlayers);\n    }\n  }, [fetchedPlayers, fetching, error]);\n  return {\n    players,\n    fetching,\n    fetchingMore: shouldAppend.current,\n    error,\n    aggregates,\n    queryVariables,\n    setQueryVariable,\n    resetFilter,\n    totalCount,\n    nextPage,\n    moreAvailable\n  };\n};\nexport const useFiltersUsed = queryVariables => {\n  const playerTypesFilterUsed = useMemo(() => {\n    var _queryVariables$playe;\n\n    return ((_queryVariables$playe = queryVariables.playerTypeIds) === null || _queryVariables$playe === void 0 ? void 0 : _queryVariables$playe.length) > 0;\n  }, [queryVariables.playerTypeIds]);\n  const searchFilterUsed = useMemo(() => queryVariables.search !== '%%', [queryVariables.search]);\n  const availabilityFilterUsed = useMemo(() => queryVariables.availability > 0, [queryVariables.availability]);\n  const skillIdsFilterUsed = useMemo(() => {\n    var _queryVariables$skill;\n\n    return ((_queryVariables$skill = queryVariables.skillIds) === null || _queryVariables$skill === void 0 ? void 0 : _queryVariables$skill.length) > 0;\n  }, [queryVariables.skillIds]);\n  const timezonesFilterUsed = useMemo(() => {\n    var _queryVariables$timez;\n\n    return ((_queryVariables$timez = queryVariables.timezones) === null || _queryVariables$timez === void 0 ? void 0 : _queryVariables$timez.length) > 0;\n  }, [queryVariables.timezones]);\n  const filtersUsed = useMemo(() => playerTypesFilterUsed || searchFilterUsed || availabilityFilterUsed || skillIdsFilterUsed || timezonesFilterUsed, [playerTypesFilterUsed, searchFilterUsed, availabilityFilterUsed, skillIdsFilterUsed, timezonesFilterUsed]);\n  return filtersUsed;\n};\n\nconst usePaginatedPlayers = (queryVariables, setQueryVariable) => {\n  const {\n    fetching,\n    players: fetchedPlayers,\n    totalCount,\n    error\n  } = useFilteredPlayers(queryVariables);\n  const itemsPerPage = PLAYER_LIMIT;\n  const maxPage = Math.ceil(totalCount / itemsPerPage);\n  const currentOffset = useMemo(() => queryVariables.offset || 0, [queryVariables.offset]);\n  const currentPage = useMemo(() => Math.ceil(currentOffset / itemsPerPage) + 1, [currentOffset, itemsPerPage]);\n  const nextPage = useCallback(() => {\n    if (currentPage < maxPage && !fetching) {\n      setQueryVariable('offset', currentOffset + itemsPerPage);\n    }\n  }, [fetching, setQueryVariable, currentOffset, itemsPerPage, currentPage, maxPage]);\n  return {\n    nextPage,\n    fetchedPlayers,\n    totalCount,\n    fetching,\n    error,\n    moreAvailable: currentPage < maxPage\n  };\n};","map":{"version":3,"sources":["/Users/mark.wagner/Dropbox/projects/TheGame/packages/web/lib/hooks/players.ts"],"names":["useGetPlayerFiltersQuery","useGetPlayersQuery","defaultQueryVariables","PLAYER_LIMIT","useCallback","useEffect","useMemo","useRef","useState","parseSkills","usePlayerAggregates","data","skillChoices","skill","skillCategories","skill_aggregate","nodes","playerTypes","player_type","map","value","label","toString","useFilteredPlayers","queryVariables","variables","setVariables","fetching","error","players","player","totalCount","player_aggregate","aggregate","count","usePlayerFilter","defaultVariables","setQueryVariables","aggregates","shouldAppend","setQueryVariable","key","Error","oldQueryVariables","limit","offset","current","resetFilter","fetchedPlayers","nextPage","moreAvailable","usePaginatedPlayers","setPlayers","p","fetchingMore","useFiltersUsed","playerTypesFilterUsed","playerTypeIds","length","searchFilterUsed","search","availabilityFilterUsed","availability","skillIdsFilterUsed","skillIds","timezonesFilterUsed","timezones","filtersUsed","itemsPerPage","maxPage","Math","ceil","currentOffset","currentPage"],"mappings":"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","sourcesContent":["import {\n  GetPlayersQueryVariables,\n  PlayerFragmentFragment,\n  useGetPlayerFiltersQuery,\n  useGetPlayersQuery,\n} from 'graphql/autogen/types';\nimport { defaultQueryVariables, PLAYER_LIMIT } from 'graphql/getPlayers';\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { CategoryOption, parseSkills } from 'utils/skillHelpers';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type QueryVariableSetter = (key: string, value: any) => void;\n\nexport interface PlayerAggregates {\n  skillCategories: { name: string }[];\n  playerTypes: { value: string; label: string }[];\n  skillChoices: CategoryOption[];\n}\n\ninterface PlayerFilter {\n  players: PlayerFragmentFragment[];\n  totalCount: number;\n  fetching: boolean;\n  fetchingMore: boolean;\n  aggregates: PlayerAggregates;\n  queryVariables: GetPlayersQueryVariables;\n  setQueryVariable: QueryVariableSetter;\n  error?: Error;\n  resetFilter: () => void;\n  nextPage: () => void;\n  moreAvailable: boolean;\n}\n\nconst usePlayerAggregates = () => {\n  const [{ data }] = useGetPlayerFiltersQuery();\n  const skillChoices = useMemo(() => parseSkills(data?.skill || []), [data]);\n  return {\n    skillCategories: data?.skill_aggregate.nodes || [],\n    playerTypes: (data?.player_type || []).map(({ value, label }) => ({\n      value: value.toString(),\n      label,\n    })),\n    skillChoices,\n  };\n};\n\nconst useFilteredPlayers = (queryVariables: GetPlayersQueryVariables) => {\n  const [variables, setVariables] = useState<GetPlayersQueryVariables>(\n    defaultQueryVariables,\n  );\n\n  useEffect(() => {\n    setVariables(queryVariables);\n  }, [queryVariables]);\n\n  const [{ fetching, data, error }] = useGetPlayersQuery({\n    variables,\n  });\n\n  const players = data?.player || [];\n  const totalCount = data?.player_aggregate.aggregate?.count || 0;\n\n  return { fetching, players, totalCount, error };\n};\n\nexport const usePlayerFilter = (\n  defaultVariables: GetPlayersQueryVariables = defaultQueryVariables,\n): PlayerFilter => {\n  const [\n    queryVariables,\n    setQueryVariables,\n  ] = useState<GetPlayersQueryVariables>(defaultVariables);\n\n  const aggregates = usePlayerAggregates();\n\n  const shouldAppend = useRef(false);\n  const setQueryVariable: QueryVariableSetter = useCallback(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (key: string, value: any) => {\n      if (key === 'limit') {\n        throw new Error('Cannot update limit');\n      }\n      setQueryVariables((oldQueryVariables) => ({\n        ...oldQueryVariables,\n        limit: PLAYER_LIMIT,\n        offset: 0,\n        [key]: value !== '' ? value : null,\n      }));\n      shouldAppend.current = key === 'offset';\n    },\n    [],\n  );\n\n  const resetFilter = () => setQueryVariables(defaultQueryVariables);\n\n  const {\n    fetchedPlayers,\n    fetching,\n    error,\n    nextPage,\n    totalCount,\n    moreAvailable,\n  } = usePaginatedPlayers(queryVariables, setQueryVariable);\n\n  const [players, setPlayers] = useState<PlayerFragmentFragment[]>(\n    fetchedPlayers,\n  );\n\n  useEffect(() => {\n    if (error || fetching) {\n      if (error || !shouldAppend.current) {\n        setPlayers([]);\n      }\n    } else if (shouldAppend.current) {\n      setPlayers((p) => [...p, ...fetchedPlayers]);\n      shouldAppend.current = false;\n    } else {\n      setPlayers(fetchedPlayers);\n    }\n  }, [fetchedPlayers, fetching, error]);\n\n  return {\n    players,\n    fetching,\n    fetchingMore: shouldAppend.current,\n    error,\n    aggregates,\n    queryVariables,\n    setQueryVariable,\n    resetFilter,\n    totalCount,\n    nextPage,\n    moreAvailable,\n  };\n};\n\nexport const useFiltersUsed = (\n  queryVariables: GetPlayersQueryVariables,\n): boolean => {\n  const playerTypesFilterUsed = useMemo(\n    () => (queryVariables.playerTypeIds as number[])?.length > 0,\n    [queryVariables.playerTypeIds],\n  );\n  const searchFilterUsed = useMemo(() => queryVariables.search !== '%%', [\n    queryVariables.search,\n  ]);\n  const availabilityFilterUsed = useMemo(\n    () => (queryVariables.availability as number) > 0,\n    [queryVariables.availability],\n  );\n  const skillIdsFilterUsed = useMemo(\n    () => (queryVariables.skillIds as string[])?.length > 0,\n    [queryVariables.skillIds],\n  );\n  const timezonesFilterUsed = useMemo(\n    () => (queryVariables.timezones as string[])?.length > 0,\n    [queryVariables.timezones],\n  );\n\n  const filtersUsed = useMemo(\n    () =>\n      playerTypesFilterUsed ||\n      searchFilterUsed ||\n      availabilityFilterUsed ||\n      skillIdsFilterUsed ||\n      timezonesFilterUsed,\n    [\n      playerTypesFilterUsed,\n      searchFilterUsed,\n      availabilityFilterUsed,\n      skillIdsFilterUsed,\n      timezonesFilterUsed,\n    ],\n  );\n\n  return filtersUsed;\n};\n\nconst usePaginatedPlayers = (\n  queryVariables: GetPlayersQueryVariables,\n  setQueryVariable: QueryVariableSetter,\n) => {\n  const {\n    fetching,\n    players: fetchedPlayers,\n    totalCount,\n    error,\n  } = useFilteredPlayers(queryVariables);\n\n  const itemsPerPage = PLAYER_LIMIT;\n  const maxPage = Math.ceil(totalCount / itemsPerPage);\n  const currentOffset = useMemo(() => (queryVariables.offset as number) || 0, [\n    queryVariables.offset,\n  ]);\n  const currentPage = useMemo(\n    () => Math.ceil(currentOffset / itemsPerPage) + 1,\n    [currentOffset, itemsPerPage],\n  );\n\n  const nextPage = useCallback(() => {\n    if (currentPage < maxPage && !fetching) {\n      setQueryVariable('offset', currentOffset + itemsPerPage);\n    }\n  }, [\n    fetching,\n    setQueryVariable,\n    currentOffset,\n    itemsPerPage,\n    currentPage,\n    maxPage,\n  ]);\n\n  return {\n    nextPage,\n    fetchedPlayers,\n    totalCount,\n    fetching,\n    error,\n    moreAvailable: currentPage < maxPage,\n  };\n};\n"]},"metadata":{},"sourceType":"module"}