"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _postmsgRpc = require("postmsg-rpc");

var _utils = require("identity-wallet/lib/utils");

var IdentityWallet = require('identity-wallet');

var Url = require('url-parse');

var store = require('store');

var _require = require('./utils'),
    isLinked = _require.isLinked;

var consentKey = function consentKey(address, domain, space) {
  return "3id_consent_".concat(address, "_").concat(domain, "_").concat(space);
};

var serializedKey = function serializedKey(address) {
  return "serialized3id_".concat(address);
};

var mobileRegex = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i;

var checkIsMobile = function checkIsMobile() {
  return mobileRegex.test(navigator.userAgent);
};
/**
 *  ThreeIdConnectService runs an identity wallet instance and rpc server with
 *  bindings to receive and relay rpc messages to identity wallet
 */


var ThreeIdConnectService = /*#__PURE__*/function () {
  /**
    * Create ThreeIdConnectService
    */
  function ThreeIdConnectService() {
    (0, _classCallCheck2["default"])(this, ThreeIdConnectService);

    this._registerDisplayListeners();

    this._registerExternalAuthListeners();
  }
  /**
   * Registers rpc call function for display and hiding iframe (Note: reverse of
   * idw rpc calls, this is rpc client, sending messages to parent window)
   * @private
   */


  (0, _createClass2["default"])(ThreeIdConnectService, [{
    key: "_registerDisplayListeners",
    value: function _registerDisplayListeners() {
      this.display = (0, _postmsgRpc.caller)('display', {
        postMessage: window.parent.postMessage.bind(window.parent)
      });
      this.hide = (0, _postmsgRpc.caller)('hide', {
        postMessage: window.parent.postMessage.bind(window.parent)
      });
    }
    /**
     * Registers rpc call functions for handling external auth calls needed for IDW to parent window
     * @private
     */

  }, {
    key: "_registerExternalAuthListeners",
    value: function _registerExternalAuthListeners() {
      this.migration = (0, _postmsgRpc.caller)('migration', {
        postMessage: window.parent.postMessage.bind(window.parent)
      });
      this.authenticate = (0, _postmsgRpc.caller)('authenticate', {
        postMessage: window.parent.postMessage.bind(window.parent)
      });
      this.createLink = (0, _postmsgRpc.caller)('createLink', {
        postMessage: window.parent.postMessage.bind(window.parent)
      });
    }
    /**
      *  External Authencation method for IDW
      *
      * @param     {Object}    params
      * @param     {String}    params.address     An ethereum address
      * @param     {Array}     params.spaces      Array of space strings
      * @param     {String}    params.type        Type of external auth request
      * @return    {Object}                       Response depends on type of request
    */

  }, {
    key: "externalAuth",
    value: function () {
      var _externalAuth = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(_ref) {
        var address, spaces, type, did, threeId, message, new3id, cached3id, diffSpaces, migration3id, new3idSerialized, link;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                address = _ref.address, spaces = _ref.spaces, type = _ref.type, did = _ref.did;

                if (!(type === '3id_auth')) {
                  _context.next = 6;
                  break;
                }

                // TODO IMPLEMENT full migration
                message = 'Add this account as a 3ID authentication method';
                return _context.abrupt("return", this.authenticate(message, address));

              case 6:
                if (!(type === '3id_migration')) {
                  _context.next = 23;
                  break;
                }

                cached3id = this._get3idState(address);

                if (!cached3id) {
                  this.linkPromise = isLinked(address);
                }

                diffSpaces = this._diff3idState(cached3id, address, spaces);

                if (!diffSpaces) {
                  _context.next = 17;
                  break;
                }

                _context.next = 13;
                return this.migration(diffSpaces, address);

              case 13:
                migration3id = _context.sent;
                new3id = this._merge3idState(cached3id, JSON.parse(migration3id));
                _context.next = 18;
                break;

              case 17:
                new3id = cached3id;

              case 18:
                new3idSerialized = JSON.stringify(new3id);

                this._write3idState(new3idSerialized, address);

                return _context.abrupt("return", new3idSerialized);

              case 23:
                if (!(type === '3id_createLink')) {
                  _context.next = 30;
                  break;
                }

                if (!this.linkPromise) {
                  _context.next = 30;
                  break;
                }

                _context.next = 27;
                return this.linkPromise;

              case 27:
                link = _context.sent;

                if (link) {
                  _context.next = 30;
                  break;
                }

                return _context.abrupt("return", this.createLink(did, address));

              case 30:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function externalAuth(_x) {
        return _externalAuth.apply(this, arguments);
      }

      return externalAuth;
    }()
  }, {
    key: "_write3idState",
    value: function _write3idState(state, address) {
      store.set(serializedKey(address), state);
    }
  }, {
    key: "_get3idState",
    value: function _get3idState(address) {
      var cached3id = store.get(serializedKey(address));
      return cached3id ? JSON.parse(cached3id) : null;
    }
  }, {
    key: "_merge3idState",
    value: function _merge3idState(target, apply) {
      if (!target) return apply;
      var res = Object.assign({}, target);
      res.spaceSeeds = Object.assign(target.spaceSeeds, apply.spaceSeeds || {});
      return res;
    }
  }, {
    key: "_diff3idState",
    value: function _diff3idState(cached3id, address, spaces) {
      if (!cached3id) return spaces;
      var cacheSpaces = Object.keys(cached3id.spaceSeeds);
      var diff = spaces.filter(function (x) {
        return !cacheSpaces.includes(x);
      });
      return diff.length === 0 ? null : diff;
    }
    /**
      *  Tells parent window to display iframe
      */

  }, {
    key: "displayIframe",
    value: function () {
      var _displayIframe = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                return _context2.abrupt("return", this.display(checkIsMobile()));

              case 1:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function displayIframe() {
        return _displayIframe.apply(this, arguments);
      }

      return displayIframe;
    }()
    /**
      *  Tells parent window to hide iframe
      */

  }, {
    key: "hideIframe",
    value: function () {
      var _hideIframe = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3() {
        var root;
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                root = document.getElementById('root');
                if (root) root.innerHTML = "";
                return _context3.abrupt("return", this.hide());

              case 3:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function hideIframe() {
        return _hideIframe.apply(this, arguments);
      }

      return hideIframe;
    }()
    /**
      *  Removes cache consents. For partial migration in instance consent function
      *  returns, but external auth to support consents fails. Refactored in future.
      *
      * @private
      * @param     {Object}    message    IDW rpc request message
      * @param     {String}    domain     Origin of caller/request
      * @return    {ThreeId}
      */

  }, {
    key: "_removeConsents",
    value: function _removeConsents(message, domain) {
      var spaces = (0, _toConsumableArray2["default"])(message.params.spaces);
      var rootKeys = store.get(serializedKey(message.params.address)); //TODO current root 'space', name

      if (!rootKeys) spaces.push('undefined');
      spaces.forEach(function (space) {
        var key = consentKey(message.params.address, domain, space);
        store.remove(key);
      });
    }
    /**
      *  Start identity wallet service. Once returns ready to receive rpc requests
      *
      * @param     {Web3Modal}   web3Modal    configured instance of web3modal
      * @param     {Function}    getConsent   get consent function, reference IDW
      * @param     {Function}    erroCB       Function to handle errors, function consumes error string (err) => {...}, called on errors
      * @param     {Function}    cancel       Function to cancel request, consumes callback, which is called when request is cancelled (cb) => {...}
      */

  }, {
    key: "start",
    value: function start(getConsent, errorCb, cancel) {
      this.cancel = cancel;
      this.errorCb = errorCb;
      this.idWallet = new IdentityWallet(getConsent, {
        externalAuth: this.externalAuth.bind(this)
      });
      this.provider = this.idWallet.get3idProvider();
      (0, _postmsgRpc.expose)('send', this.providerRelay.bind(this), {
        postMessage: window.parent.postMessage.bind(window.parent)
      });
    }
    /**
      *  Consumes IDW RPC request message and relays to IDW instance. Also handles
      *  logic to retry requests and cancel requests.
      *
      * @param     {Object}      message    IDW RPC request message
      * @return    {String}                 response message string
      */

  }, {
    key: "providerRelay",
    value: function () {
      var _providerRelay = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee5(message) {
        var _this = this;

        var domain, responsePromise;
        return _regenerator["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                domain = new Url(document.referrer).host;
                responsePromise = new Promise( /*#__PURE__*/function () {
                  var _ref2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4(resolve, reject) {
                    var res, _res;

                    return _regenerator["default"].wrap(function _callee4$(_context4) {
                      while (1) {
                        switch (_context4.prev = _context4.next) {
                          case 0:
                            // Register request cancel calback
                            // TODO could make all rpc errors match spec
                            _this.cancel(function () {
                              var res = {
                                'id': message.id,
                                'json-rpc': '2.0',
                                error: "3id-connect: Request not authorized"
                              };
                              resolve(res);
                            });

                            if (!(message.method === '3id_authenticate')) {
                              _context4.next = 16;
                              break;
                            }

                            _context4.prev = 2;
                            _context4.next = 5;
                            return _this.provider.send(message, domain);

                          case 5:
                            res = _context4.sent;

                            _this.hideIframe();

                            resolve(res);
                            _context4.next = 14;
                            break;

                          case 10:
                            _context4.prev = 10;
                            _context4.t0 = _context4["catch"](2);

                            _this.errorCb(_context4.t0, 'Error: Unable to connect');

                            _this._removeConsents(message, domain);

                          case 14:
                            _context4.next = 20;
                            break;

                          case 16:
                            _context4.next = 18;
                            return _this.provider.send(message, domain);

                          case 18:
                            _res = _context4.sent;
                            resolve(_res);

                          case 20:
                          case "end":
                            return _context4.stop();
                        }
                      }
                    }, _callee4, null, [[2, 10]]);
                  }));

                  return function (_x3, _x4) {
                    return _ref2.apply(this, arguments);
                  };
                }());
                _context5.t0 = JSON;
                _context5.next = 5;
                return responsePromise;

              case 5:
                _context5.t1 = _context5.sent;
                return _context5.abrupt("return", _context5.t0.stringify.call(_context5.t0, _context5.t1));

              case 7:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5);
      }));

      function providerRelay(_x2) {
        return _providerRelay.apply(this, arguments);
      }

      return providerRelay;
    }()
  }]);
  return ThreeIdConnectService;
}();

var _default = ThreeIdConnectService;
exports["default"] = _default;