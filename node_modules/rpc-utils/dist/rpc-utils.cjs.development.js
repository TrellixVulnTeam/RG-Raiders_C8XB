'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var nanoid = require('nanoid');

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

var _ERROR_MESSAGE;

(function (ERROR_CODE) {
  ERROR_CODE[ERROR_CODE["PARSE_ERROR"] = -32700] = "PARSE_ERROR";
  ERROR_CODE[ERROR_CODE["INVALID_REQUEST"] = -32600] = "INVALID_REQUEST";
  ERROR_CODE[ERROR_CODE["METHOD_NOT_FOUND"] = -32601] = "METHOD_NOT_FOUND";
  ERROR_CODE[ERROR_CODE["INVALID_PARAMS"] = -32602] = "INVALID_PARAMS";
  ERROR_CODE[ERROR_CODE["INTERNAL_ERROR"] = -32603] = "INTERNAL_ERROR";
})(exports.ERROR_CODE || (exports.ERROR_CODE = {}));

var ERROR_MESSAGE = (_ERROR_MESSAGE = {}, _ERROR_MESSAGE[exports.ERROR_CODE.PARSE_ERROR] = 'Parse error', _ERROR_MESSAGE[exports.ERROR_CODE.INVALID_REQUEST] = 'Invalid request', _ERROR_MESSAGE[exports.ERROR_CODE.METHOD_NOT_FOUND] = 'Method not found', _ERROR_MESSAGE[exports.ERROR_CODE.INVALID_PARAMS] = 'Invalid params', _ERROR_MESSAGE[exports.ERROR_CODE.INTERNAL_ERROR] = 'Internal error', _ERROR_MESSAGE);
function isServerError(code) {
  return -32000 >= code && code >= -32099;
}
function getErrorMessage(code) {
  var _ERROR_MESSAGE$code$t;

  return (_ERROR_MESSAGE$code$t = ERROR_MESSAGE[code.toString()]) !== null && _ERROR_MESSAGE$code$t !== void 0 ? _ERROR_MESSAGE$code$t : isServerError(code) ? 'Server error' : 'Application error';
}
var RPCError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(RPCError, _Error);

  function RPCError(code, message, data) {
    var _this;

    _this = _Error.call(this) || this;
    Object.setPrototypeOf(_assertThisInitialized(_this), RPCError.prototype);
    _this.code = code;
    _this.data = data;
    _this.message = message !== null && message !== void 0 ? message : getErrorMessage(code);
    return _this;
  }

  RPCError.fromObject = function fromObject(err) {
    return new RPCError(err.code, err.message, err.data);
  };

  var _proto = RPCError.prototype;

  _proto.toObject = function toObject() {
    return {
      code: this.code,
      data: this.data,
      message: this.message
    };
  };

  return RPCError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

function createErrorFactory(code) {
  var message = ERROR_MESSAGE[code];
  return function createError(data) {
    return new RPCError(code, message, data);
  };
}

var createParseError = /*#__PURE__*/createErrorFactory(exports.ERROR_CODE.PARSE_ERROR);
var createInvalidRequest = /*#__PURE__*/createErrorFactory(exports.ERROR_CODE.INVALID_REQUEST);
var createMethodNotFound = /*#__PURE__*/createErrorFactory(exports.ERROR_CODE.METHOD_NOT_FOUND);
var createInvalidParams = /*#__PURE__*/createErrorFactory(exports.ERROR_CODE.INVALID_PARAMS);
var createInternalError = /*#__PURE__*/createErrorFactory(exports.ERROR_CODE.INTERNAL_ERROR);

var RPCClient = /*#__PURE__*/function () {
  function RPCClient(connection) {
    this.connection = connection;
  }

  var _proto = RPCClient.prototype;

  _proto.createID = function createID() {
    return nanoid.nanoid();
  };

  _proto.request = function request(method, params) {
    try {
      var _this2 = this;

      return Promise.resolve(_this2.connection.send({
        jsonrpc: '2.0',
        id: _this2.createID(),
        method: method,
        params: params
      })).then(function (res) {
        if (res == null) {
          throw new Error('Missing response');
        }

        if (res.error != null) {
          throw RPCError.fromObject(res.error);
        }

        return res.result;
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  return RPCClient;
}();

// A type of promise-like that resolves synchronously and supports only one observer

const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator"))) : "@@iterator";

const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator"))) : "@@asyncIterator";

// Asynchronously call a function and send errors to recovery continuation
function _catch(body, recover) {
	try {
		var result = body();
	} catch(e) {
		return recover(e);
	}
	if (result && result.then) {
		return result.then(void 0, recover);
	}
	return result;
}

function parseJSON(input) {
  try {
    return JSON.parse(input);
  } catch (err) {
    throw createParseError();
  }
}
function createErrorResponse(id, code) {
  return {
    jsonrpc: '2.0',
    id: id,
    error: {
      code: code,
      message: getErrorMessage(code)
    }
  };
}

function fallbackOnHandlerError(_ctx, msg, error) {
  // eslint-disable-next-line no-console
  console.warn('Unhandled handler error', msg, error);
}

function fallbackOnInvalidMessage(_ctx, msg) {
  // eslint-disable-next-line no-console
  console.warn('Unhandled invalid message', msg);
}

function fallbackOnNotification(_ctx, msg) {
  // eslint-disable-next-line no-console
  console.warn('Unhandled notification', msg);
}

function createHandler(methods, options) {
  var _options$onHandlerErr, _options$onInvalidMes, _options$onNotificati;

  if (options === void 0) {
    options = {};
  }

  var onHandlerError = (_options$onHandlerErr = options.onHandlerError) !== null && _options$onHandlerErr !== void 0 ? _options$onHandlerErr : fallbackOnHandlerError;
  var onInvalidMessage = (_options$onInvalidMes = options.onInvalidMessage) !== null && _options$onInvalidMes !== void 0 ? _options$onInvalidMes : fallbackOnInvalidMessage;
  var onNotification = (_options$onNotificati = options.onNotification) !== null && _options$onNotificati !== void 0 ? _options$onNotificati : fallbackOnNotification;
  return function handleRequest(ctx, msg) {
    try {
      var id = msg.id;

      if (msg.jsonrpc !== '2.0' || msg.method == null) {
        if (id == null) {
          onInvalidMessage(ctx, msg);
          return Promise.resolve(null);
        }

        return Promise.resolve(createErrorResponse(id, exports.ERROR_CODE.INVALID_REQUEST));
      }

      if (id == null) {
        onNotification(ctx, msg);
        return Promise.resolve(null);
      }

      var handler = methods[msg.method];

      if (handler == null) {
        return Promise.resolve(createErrorResponse(id, exports.ERROR_CODE.METHOD_NOT_FOUND));
      }

      return Promise.resolve(_catch(function () {
        var _msg$params;

        function _temp2(result) {
          return {
            jsonrpc: '2.0',
            id: id,
            result: result
          };
        }

        var handled = handler(ctx, (_msg$params = msg.params) !== null && _msg$params !== void 0 ? _msg$params : {});

        var _temp = typeof handled.then === 'function';

        return _temp ? Promise.resolve(handled).then(_temp2) : _temp2(handled);
      }, function (err) {
        var error;

        if (err instanceof RPCError) {
          error = err.toObject();
        } else {
          var _err$code;

          onHandlerError(ctx, msg, err);
          var code = (_err$code = err.code) !== null && _err$code !== void 0 ? _err$code : -32000; // Server error

          error = {
            code: code,
            message: err.message || getErrorMessage(code)
          };
        }

        return {
          jsonrpc: '2.0',
          id: id,
          error: error
        };
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  };
}

exports.ERROR_MESSAGE = ERROR_MESSAGE;
exports.RPCClient = RPCClient;
exports.RPCError = RPCError;
exports.createErrorResponse = createErrorResponse;
exports.createHandler = createHandler;
exports.createInternalError = createInternalError;
exports.createInvalidParams = createInvalidParams;
exports.createInvalidRequest = createInvalidRequest;
exports.createMethodNotFound = createMethodNotFound;
exports.createParseError = createParseError;
exports.getErrorMessage = getErrorMessage;
exports.isServerError = isServerError;
exports.parseJSON = parseJSON;
//# sourceMappingURL=rpc-utils.cjs.development.js.map
