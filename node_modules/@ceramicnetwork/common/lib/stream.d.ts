import CID from 'cids';
import type { Context } from "./context";
import { CommitID, StreamID } from '@ceramicnetwork/streamid';
import type { DagJWS, DagJWSResult } from 'dids';
import { Observable } from 'rxjs';
import { RunningStateLike } from './running-state-like';
import { CeramicApi } from "./ceramic-api";
import { LoadOpts } from "./docopts";
export declare enum SignatureStatus {
    GENESIS = 0,
    PARTIAL = 1,
    SIGNED = 2
}
export declare enum AnchorStatus {
    NOT_REQUESTED = 0,
    PENDING = 1,
    PROCESSING = 2,
    ANCHORED = 3,
    FAILED = 4
}
export interface CommitHeader {
    controllers: Array<string>;
    family?: string;
    schema?: string;
    tags?: Array<string>;
    [index: string]: any;
}
export interface GenesisHeader extends CommitHeader {
    unique?: string;
}
export declare type GenesisCommit = {
    header: GenesisHeader;
    data?: any;
};
export interface UnsignedCommit {
    id: CID;
    header?: CommitHeader;
    data: any;
    prev: CID;
}
export interface AnchorProof {
    chainId: string;
    blockNumber: number;
    blockTimestamp: number;
    txHash: CID;
    root: CID;
}
export interface AnchorCommit {
    id: CID;
    prev: CID;
    proof: CID;
    path: string;
}
export declare type SignedCommit = DagJWS;
export declare type SignedCommitContainer = DagJWSResult;
export declare type CeramicCommit = GenesisCommit | UnsignedCommit | AnchorCommit | SignedCommit | SignedCommitContainer;
export interface StreamMetadata {
    controllers: Array<string>;
    family?: string;
    schema?: string;
    tags?: Array<string>;
    [index: string]: any;
}
export interface StreamNext {
    content?: any;
    controllers?: Array<string>;
    metadata?: StreamMetadata;
}
export declare enum CommitType {
    GENESIS = 0,
    SIGNED = 1,
    ANCHOR = 2
}
export interface LogEntry {
    cid: CID;
    type: CommitType;
    timestamp?: number;
}
export interface StreamState {
    type: number;
    content: any;
    next?: StreamNext;
    metadata: StreamMetadata;
    signature: SignatureStatus;
    anchorStatus: AnchorStatus;
    anchorScheduledFor?: number;
    anchorProof?: AnchorProof;
    log: Array<LogEntry>;
}
export interface StreamStateHolder {
    id: StreamID;
    state: StreamState;
}
export declare abstract class Stream extends Observable<StreamState> implements StreamStateHolder {
    protected readonly state$: RunningStateLike;
    private _context;
    constructor(state$: RunningStateLike, _context: Context);
    get id(): StreamID;
    get api(): CeramicApi;
    get metadata(): StreamMetadata;
    get controllers(): Array<string>;
    get tip(): CID;
    get commitId(): CommitID;
    get allCommitIds(): Array<CommitID>;
    get anchorCommitIds(): Array<CommitID>;
    get state(): StreamState;
    sync(opts?: LoadOpts): Promise<void>;
    protected _getContent(): any;
    abstract makeReadOnly(): any;
}
export declare function StreamStatic<T>(): <U extends T>(constructor: U) => any;
export interface StreamConstructor<T extends Stream> {
    new (state$: RunningStateLike, context: Context): T;
}
export interface StreamHandler<T extends Stream> {
    type: number;
    name: string;
    stream_constructor: StreamConstructor<T>;
    applyCommit(commit: CeramicCommit, cid: CID, context: Context, state?: StreamState): Promise<StreamState>;
}
//# sourceMappingURL=stream.d.ts.map