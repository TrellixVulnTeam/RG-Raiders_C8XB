"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const store_1 = __importDefault(require("store"));
const did_jwt_1 = require("did-jwt");
const ipfs_did_document_1 = __importDefault(require("ipfs-did-document"));
const _3id_blockchain_utils_1 = require("3id-blockchain-utils");
const crypto_1 = require("./crypto");
const did_provider_1 = require("./did-provider");
const keyring_1 = __importDefault(require("./keyring"));
const threeIdProvider_1 = __importDefault(require("./threeIdProvider"));
const utils_1 = require("./utils");
const DID_METHOD_NAME = '3';
class IdentityWallet {
    constructor(getConsent, config = {}) {
        this.events = new events_1.EventEmitter();
        if (typeof getConsent !== 'function')
            throw new Error('getConsent parameter has to be a function');
        this._getConsent = getConsent;
        if (config.seed) {
            this._seed = config.seed;
        }
        else if (config.authSecret) {
            this._authSecret = config.authSecret;
        }
        else if (config.externalAuth) {
            this._externalAuth = config.externalAuth;
        }
        else {
            throw new Error('Either seed, or authSecret has to be passed to create an IdentityWallet instance');
        }
    }
    get3idProvider() {
        return new threeIdProvider_1.default(this);
    }
    getDidProvider() {
        return new did_provider_1.DidProvider(this);
    }
    hasConsent(spaces = [], origin, { address } = {}) {
        var _a;
        const key = (_a = address !== null && address !== void 0 ? address : this._keyring.getPublicKeys().managementKey) !== null && _a !== void 0 ? _a : '';
        const prefix = `3id_consent_${key}_${origin !== null && origin !== void 0 ? origin : ''}_`;
        const consentExists = (space = '') => Boolean(store_1.default.get(prefix + space));
        return spaces.reduce((acc, space) => acc && consentExists(space), consentExists());
    }
    getConsent(spaces = [], origin, { address } = {}) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.hasConsent(spaces, origin, { address })) {
                const consent = yield this._getConsent({
                    type: 'authenticate',
                    origin,
                    spaces,
                    opts: {
                        address,
                    },
                });
                if (!consent)
                    return false;
                const key = (_a = address !== null && address !== void 0 ? address : this._keyring.getPublicKeys().managementKey) !== null && _a !== void 0 ? _a : '';
                const prefix = `3id_consent_${key}_${origin !== null && origin !== void 0 ? origin : ''}_`;
                const saveConsent = (space = '') => store_1.default.set(prefix + space, true);
                saveConsent();
                spaces.map(saveConsent);
            }
            return true;
        });
    }
    getLink() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._seed) {
                this._keyring = new keyring_1.default(this._seed);
                this.DID = yield this._get3id();
                delete this._seed;
                yield this._linkManagementAddress();
            }
            return this._keyring
                ? this._keyring.getPublicKeys().managementKey
                : keyring_1.default.walletForAuthSecret(this._authSecret).address;
        });
    }
    getRootSigner(pubKeyId) {
        if (pubKeyId == null) {
            return this._keyring.getRootSigner();
        }
        const [did, keyId] = pubKeyId.split('#');
        if (this.DID == null || did !== this.DID) {
            throw new Error('Invalid DID');
        }
        return this._keyring.getRootSigner(keyId);
    }
    _linkManagementAddress() {
        return __awaiter(this, void 0, void 0, function* () {
            const managementWallet = this._keyring.managementWallet();
            this.events.emit('new-link-proof', yield _3id_blockchain_utils_1.createLink(this.DID, managementWallet.address, utils_1.fakeEthProvider(managementWallet)));
        });
    }
    linkAddress(address, provider) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._keyring)
                throw new Error('This method can only be called after authenticate has been called');
            const proof = yield _3id_blockchain_utils_1.createLink(this.DID, address, provider);
            this.events.emit('new-link-proof', proof);
            return proof;
        });
    }
    linkManagementKey() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._externalAuth)
                return null;
            const timestamp = Math.floor(new Date().getTime() / 1000);
            const msg = `Create a new 3Box profile\n\n- \nYour unique profile ID is ${this
                .DID} \nTimestamp: ${timestamp}`;
            return {
                msg,
                timestamp,
                sig: yield this._keyring.managementPersonalSign(msg),
            };
        });
    }
    _initKeyring(authData, address, spaces) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._seed) {
                yield this.getLink();
            }
            else if (authData && authData.length > 0) {
                let seed;
                authData.find(({ ciphertext, nonce }) => {
                    seed = keyring_1.default.decryptWithAuthSecret(ciphertext, nonce, this._authSecret);
                    return Boolean(seed);
                });
                if (!seed)
                    throw new Error('No valid auth-secret for this identity');
                this._keyring = new keyring_1.default(seed);
                this.DID = yield this._get3id();
            }
            else if (this._externalAuth) {
                if (!address)
                    throw new Error('External authentication requires an address');
                const migratedKeys = yield this._externalAuth({
                    address,
                    spaces,
                    type: '3id_migration',
                });
                this._keyring = new keyring_1.default(null, migratedKeys);
                this.DID = yield this._get3id();
                const proof = yield this._externalAuth({
                    address,
                    type: '3id_createLink',
                    did: this.DID,
                });
                if (proof)
                    this.events.emit('new-link-proof', proof);
            }
            else {
                const seed = '0x' + Buffer.from(crypto_1.naclRandom(32)).toString('hex');
                this._keyring = new keyring_1.default(seed);
                this.DID = yield this._get3id();
                yield this.addAuthMethod(this._authSecret);
            }
        });
    }
    authenticate(spaces = [], { authData, address, mgmtPub, } = {}, origin) {
        return __awaiter(this, void 0, void 0, function* () {
            let consent;
            if (address)
                consent = yield this.getConsent(spaces, origin, { address });
            if (!this._keyring || this._externalAuth)
                yield this._initKeyring(authData, address, spaces);
            if (!address)
                consent = this.getConsent(spaces, origin);
            if (!consent)
                throw new Error('Authentication not authorized by user');
            return {
                main: this._keyring.getPublicKeys({ mgmtPub }),
                spaces: spaces.reduce((acc, space) => {
                    acc[space] = this._keyring.getPublicKeys({
                        space,
                        uncompressed: true,
                    });
                    return acc;
                }, {}),
            };
        });
    }
    isAuthenticated(spaces = [], origin, { address } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return Boolean(this._keyring) && this.hasConsent(spaces, origin, { address });
        });
    }
    addAuthMethod(authSecret) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._keyring)
                throw new Error('This method can only be called after authenticate has been called');
            const message = this._keyring.serialize();
            const encAuthData = keyring_1.default.encryptWithAuthSecret(message, authSecret);
            this.events.emit('new-auth-method', encAuthData);
            const authWallet = keyring_1.default.walletForAuthSecret(authSecret);
            this.events.emit('new-link-proof', yield _3id_blockchain_utils_1.createLink(this.DID, authWallet.address, utils_1.fakeEthProvider(authWallet)));
        });
    }
    signClaim(payload, { DID, space, expiresIn, useMgmt, } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._keyring) {
                throw new Error('This method can only be called after authenticate has been called');
            }
            const issuer = DID || (yield this._get3id(space));
            const settings = {
                signer: this._keyring.getJWTSigner(space, useMgmt),
                issuer,
                expiresIn,
            };
            return did_jwt_1.createJWT(payload, settings);
        });
    }
    encrypt(message, space, { nonce, blockSize, to } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._keyring)
                throw new Error('This method can only be called after authenticate has been called');
            const paddedMsg = typeof message === 'string' ? utils_1.pad(message, blockSize) : message;
            if (to) {
                return this._keyring.asymEncrypt(paddedMsg, to, { nonce });
            }
            else {
                return this._keyring.symEncrypt(paddedMsg, { space, nonce });
            }
        });
    }
    decrypt(encObj, space, toBuffer) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._keyring)
                throw new Error('This method can only be called after authenticate has been called');
            let paddedMsg;
            if (encObj.ephemeralFrom) {
                paddedMsg = this._keyring.asymDecrypt(encObj.ciphertext, encObj.ephemeralFrom, encObj.nonce, { space, toBuffer });
            }
            else {
                paddedMsg = this._keyring.symDecrypt(encObj.ciphertext, encObj.nonce, {
                    space,
                    toBuffer,
                });
            }
            if (!paddedMsg)
                throw new Error('IdentityWallet: Could not decrypt message');
            return toBuffer ? paddedMsg : utils_1.unpad(paddedMsg);
        });
    }
    hashDBKey(key, space) {
        return __awaiter(this, void 0, void 0, function* () {
            const salt = this._keyring.getDBSalt(space);
            return utils_1.sha256Multihash(salt + key);
        });
    }
    _get3id(space) {
        return __awaiter(this, void 0, void 0, function* () {
            const pubkeys = this._keyring.getPublicKeys({ space, uncompressed: true });
            const doc = new ipfs_did_document_1.default(utils_1.fakeIpfs, DID_METHOD_NAME);
            if (!space) {
                if (this.DID)
                    return this.DID;
                doc.addPublicKey('signingKey', 'Secp256k1VerificationKey2018', 'publicKeyHex', pubkeys.signingKey);
                doc.addPublicKey('encryptionKey', 'Curve25519EncryptionPublicKey', 'publicKeyBase64', pubkeys.asymEncryptionKey);
                doc.addPublicKey('managementKey', 'Secp256k1VerificationKey2018', 'ethereumAddress', pubkeys.managementKey);
                doc.addAuthentication('Secp256k1SignatureAuthentication2018', 'signingKey');
            }
            else {
                doc.addPublicKey('subSigningKey', 'Secp256k1VerificationKey2018', 'publicKeyHex', pubkeys.signingKey);
                doc.addPublicKey('subEncryptionKey', 'Curve25519EncryptionPublicKey', 'publicKeyBase64', pubkeys.asymEncryptionKey);
                doc.addAuthentication('Secp256k1SignatureAuthentication2018', 'subSigningKey');
                doc.addCustomProperty('space', space);
                doc.addCustomProperty('root', this.DID);
                const payload = {
                    subSigningKey: pubkeys.signingKey,
                    subEncryptionKey: pubkeys.asymEncryptionKey,
                    space: space,
                    iat: null,
                };
                const signature = (yield this.signClaim(payload)).split('.')[2];
                doc.addCustomProperty('proof', { alg: 'ES256K', signature });
            }
            yield doc.commit({ noTimestamp: true });
            return doc.DID;
        });
    }
}
exports.default = IdentityWallet;
//# sourceMappingURL=identity-wallet.js.map