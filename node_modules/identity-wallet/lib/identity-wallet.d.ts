/// <reference types="node" />
import { EventEmitter } from 'events';
import { Signer } from 'did-jwt';
import { LinkProof } from '3id-blockchain-utils';
import { AsymEncryptedMessage, EncryptedMessage } from './crypto';
import { DidProvider } from './did-provider';
import Keyring, { PublicKeys } from './keyring';
import ThreeIdProvider from './threeIdProvider';
interface ConsentRequest {
    type: string;
    spaces: Array<string>;
    origin?: string | null;
    opts?: Record<string, any>;
}
declare type GetConsentFunc = (req: ConsentRequest) => Promise<boolean>;
interface Config {
    seed?: string;
    authSecret?: string;
    externalAuth?: (req: any) => Promise<any>;
}
export default class IdentityWallet {
    protected _getConsent: GetConsentFunc;
    protected _seed: string | undefined;
    protected _authSecret: string | undefined;
    protected _externalAuth: ((req: any) => Promise<any>) | undefined;
    protected _keyring: Keyring | undefined;
    DID: string | undefined;
    events: EventEmitter;
    constructor(getConsent: GetConsentFunc, config?: Config);
    get3idProvider(): ThreeIdProvider;
    getDidProvider(): DidProvider;
    hasConsent(spaces?: Array<string>, origin?: string | null, { address }?: {
        address?: string;
    }): boolean;
    getConsent(spaces?: Array<string>, origin?: string | null, { address }?: {
        address?: string;
    }): Promise<boolean>;
    getLink(): Promise<string>;
    getRootSigner(pubKeyId?: string): Signer;
    _linkManagementAddress(): Promise<void>;
    linkAddress(address: string, provider: any): Promise<LinkProof>;
    linkManagementKey(): Promise<{
        msg: string;
        timestamp: number;
        sig: string;
    } | null>;
    _initKeyring(authData?: Array<EncryptedMessage>, address?: string, spaces?: Array<string>): Promise<void>;
    authenticate(spaces?: Array<string>, { authData, address, mgmtPub, }?: {
        authData?: Array<EncryptedMessage>;
        address?: string;
        mgmtPub?: string;
    }, origin?: string | null): Promise<{
        main: PublicKeys;
        spaces: Record<string, PublicKeys>;
    }>;
    isAuthenticated(spaces?: Array<string>, origin?: string | null, { address }?: {
        address?: string;
    }): Promise<boolean>;
    addAuthMethod(authSecret: string): Promise<void>;
    signClaim(payload: any, { DID, space, expiresIn, useMgmt, }?: {
        DID?: string;
        space?: string;
        expiresIn?: number;
        useMgmt?: boolean;
    }): Promise<string>;
    encrypt(message: string | Uint8Array, space?: string, { nonce, blockSize, to }?: {
        nonce?: Uint8Array;
        blockSize?: number;
        to?: string;
    }): Promise<EncryptedMessage>;
    decrypt(encObj: EncryptedMessage | AsymEncryptedMessage, space: string | undefined, toBuffer: true): Promise<Buffer | null>;
    decrypt(encObj: EncryptedMessage | AsymEncryptedMessage, space?: string, toBuffer?: false): Promise<string | null>;
    hashDBKey(key: string, space?: string): Promise<string>;
    _get3id(space?: string): Promise<string>;
}
export {};
