"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const tweetnacl_1 = __importDefault(require("tweetnacl"));
const tweetnacl_util_1 = __importDefault(require("tweetnacl-util"));
const hdnode_1 = require("@ethersproject/hdnode");
const wallet_1 = require("@ethersproject/wallet");
const did_jwt_1 = require("did-jwt");
const js_sha256_1 = require("js-sha256");
const elliptic_1 = require("elliptic");
const crypto_1 = require("./crypto");
const utils_1 = require("./utils");
const ec = new elliptic_1.ec('secp256k1');
const BASE_PATH = "m/51073068'/0'";
const ROOT_STORE_PATH = "0'/0'/0'/0'/0'/0'/0'/0'";
const BASE_PATH_LEGACY = "m/7696500'/0'/0'";
const AUTH_PATH_WALLET = BASE_PATH + '/' + ROOT_STORE_PATH + '/0';
const AUTH_PATH_ENCRYPTION = BASE_PATH + '/' + ROOT_STORE_PATH + '/3';
const ensure0x = (str) => {
    return (str.startsWith('0x') ? '' : '0x') + str;
};
class Keyring {
    constructor(seed, migratedKeys) {
        this._spaceKeys = {};
        this._migratedKeys = false;
        if (seed) {
            this._seed = seed;
            this._baseNode = hdnode_1.HDNode.fromSeed(this._seed).derivePath(BASE_PATH);
            const rootNode = this._baseNode.derivePath(ROOT_STORE_PATH);
            this._rootKeys = this._deriveRootKeySet(rootNode);
        }
        if (migratedKeys) {
            this._migratedKeys = true;
            this._importMigratedKeys(migratedKeys);
        }
        if (!(seed || migratedKeys))
            throw new Error('One or both of seed or migratedKeys required');
    }
    _importMigratedKeys(migratedKeysString) {
        const migratedKeys = JSON.parse(migratedKeysString);
        const getHDNode = (seed) => {
            const seedNode = hdnode_1.HDNode.fromSeed(seed);
            return seedNode.derivePath(BASE_PATH_LEGACY);
        };
        const rootNode = getHDNode(migratedKeys.seed);
        this._rootKeys = this._deriveRootKeySet(rootNode);
        this._rootKeys.managementAddress = migratedKeys.managementAddress;
        this._rootKeys.managementKey = { address: migratedKeys.managementAddress };
        Object.keys(migratedKeys.spaceSeeds).map((name) => {
            const spaceNode = getHDNode(migratedKeys.spaceSeeds[name]);
            this._spaceKeys[name] = this._deriveKeySet(spaceNode);
        });
    }
    _deriveKeySet(hdNode) {
        return {
            signingKey: hdNode.derivePath('0'),
            asymEncryptionKey: tweetnacl_1.default.box.keyPair.fromSecretKey(new Uint8Array(Buffer.from(hdNode.derivePath('2').privateKey.slice(2), 'hex'))),
            symEncryptionKey: utils_1.hexToUint8Array(hdNode.derivePath('3').privateKey.slice(2)),
        };
    }
    _deriveRootKeySet(hdNode) {
        return Object.assign(Object.assign({}, this._deriveKeySet(hdNode)), { managementKey: hdNode.derivePath('1') });
    }
    _deriveSpaceKeys(space) {
        var _a, _b;
        const spaceHash = js_sha256_1.sha256(`${space}.3box`);
        const spacePath = (_b = (_a = spaceHash
            .match(/.{1,12}/g)) === null || _a === void 0 ? void 0 : _a.map((n) => parseInt(n, 16).toString(2)).map((n) => `${n.length === 47 ? '0' : ''}${n}`).join('').match(/.{1,31}/g)) === null || _b === void 0 ? void 0 : _b.map((n) => parseInt(n, 2)).join("'/");
        const spaceNode = this._baseNode.derivePath(`${spacePath}'`);
        this._spaceKeys[space] = this._deriveKeySet(spaceNode);
    }
    _getKeys(space) {
        if (!space) {
            return this._rootKeys;
        }
        else if (!this._spaceKeys[space]) {
            if (this._migratedKeys)
                throw new Error('Can not derive space keys, not given in migrated keys');
            this._deriveSpaceKeys(space);
        }
        return this._spaceKeys[space];
    }
    asymEncrypt(msg, toPublic, { nonce } = {}) {
        return crypto_1.asymEncrypt(msg, toPublic, nonce);
    }
    asymDecrypt(ciphertext, fromPublic, nonce, { space, toBuffer } = {}) {
        const key = this._getKeys(space).asymEncryptionKey.secretKey;
        return crypto_1.asymDecrypt(ciphertext, fromPublic, key, nonce, toBuffer);
    }
    symEncrypt(msg, { space, nonce } = {}) {
        return crypto_1.symEncryptBase(msg, this._getKeys(space).symEncryptionKey, nonce);
    }
    symDecrypt(ciphertext, nonce, { space, toBuffer } = {}) {
        return crypto_1.symDecryptBase(ciphertext, this._getKeys(space).symEncryptionKey, nonce, toBuffer);
    }
    managementPersonalSign(message) {
        return __awaiter(this, void 0, void 0, function* () {
            const wallet = this.managementWallet();
            return yield wallet.signMessage(message);
        });
    }
    managementWallet() {
        const node = this._rootKeys.managementKey;
        return new wallet_1.Wallet(node.privateKey);
    }
    getJWTSigner(space, useMgmt) {
        const pubkeys = this._getKeys(space);
        const key = useMgmt ? pubkeys.managementKey : pubkeys.signingKey;
        return did_jwt_1.EllipticSigner(key.privateKey.slice(2));
    }
    getRootSigner(keyId) {
        var _a, _b;
        const key = keyId === 'managementKey' ? (_a = this._rootKeys) === null || _a === void 0 ? void 0 : _a.managementKey : (_b = this._rootKeys) === null || _b === void 0 ? void 0 : _b.signingKey;
        if (key == null || !(key instanceof hdnode_1.HDNode)) {
            throw new Error('Invalid key');
        }
        return did_jwt_1.EllipticSigner(key.privateKey.slice(2));
    }
    getDBSalt(space) {
        return js_sha256_1.sha256(this._getKeys(space).signingKey.derivePath('0').privateKey.slice(2));
    }
    getPublicKeys({ space, uncompressed, mgmtPub, } = {}) {
        const keys = this._getKeys(space);
        let signingKey = keys.signingKey.publicKey.slice(2);
        const managementKey = space
            ? null
            : mgmtPub && keys.managementKey.publicKey
                ? keys.managementKey.publicKey.slice(2)
                : keys.managementKey.address;
        if (uncompressed) {
            signingKey = ec.keyFromPublic(Buffer.from(signingKey, 'hex')).getPublic(false, 'hex');
        }
        return {
            signingKey,
            managementKey,
            asymEncryptionKey: tweetnacl_util_1.default.encodeBase64(keys.asymEncryptionKey.publicKey),
        };
    }
    serialize() {
        return this._seed;
    }
    static encryptWithAuthSecret(message, authSecret) {
        const node = hdnode_1.HDNode.fromSeed(ensure0x(authSecret)).derivePath(AUTH_PATH_ENCRYPTION);
        const key = utils_1.hexToUint8Array(node.privateKey.slice(2));
        return crypto_1.symEncryptBase(message, key);
    }
    static decryptWithAuthSecret(ciphertext, nonce, authSecret) {
        const node = hdnode_1.HDNode.fromSeed(ensure0x(authSecret)).derivePath(AUTH_PATH_ENCRYPTION);
        const key = utils_1.hexToUint8Array(node.privateKey.slice(2));
        return crypto_1.symDecryptBase(ciphertext, key, nonce);
    }
    static walletForAuthSecret(authSecret) {
        const node = hdnode_1.HDNode.fromSeed(ensure0x(authSecret)).derivePath(AUTH_PATH_WALLET);
        return new wallet_1.Wallet(node.privateKey);
    }
}
exports.default = Keyring;
//# sourceMappingURL=keyring.js.map