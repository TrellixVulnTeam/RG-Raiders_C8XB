"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var _require = require('@ethersproject/hdnode'),
    mnemonicToSeed = _require.mnemonicToSeed,
    entropyToMnemonic = _require.entropyToMnemonic;

var EventEmitter = require('events');

var didJWT = require('did-jwt');

var _require2 = require('did-resolver'),
    Resolver = _require2.Resolver;

var get3IdResolver = require('3id-resolver').getResolver;

var getMuportResolver = require('muport-did-resolver').getResolver;

var DidDocument = require('ipfs-did-document');

var localstorage = require('store');

var Identities = require('orbit-db-identity-provider');

var _require3 = require('3box-orbitdb-plugins'),
    OdbIdentityProvider = _require3.OdbIdentityProvider;

Identities.addIdentityProvider(OdbIdentityProvider);

var utils = require('../utils/index');

var Keyring = require('./keyring');

var config = require('../config.js');

var nacl = require('tweetnacl');

var _require4 = require('./utils'),
    randomNonce = _require4.randomNonce;

var DID_METHOD_NAME = '3';
var STORAGE_KEY = 'serialized3id_';
var MUPORT_IPFS = {
  host: config.muport_ipfs_host,
  port: config.muport_ipfs_port,
  protocol: config.muport_ipfs_protocol
};
var POLL_INTERVAL = 500;

var ThreeId = /*#__PURE__*/function () {
  function ThreeId(provider, ipfs, keystore) {
    var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    (0, _classCallCheck2["default"])(this, ThreeId);
    this.events = new EventEmitter();
    this._provider = provider;
    this._has3idProv = Boolean(opts.has3idProv);
    this._ipfs = ipfs;
    this._muportIpfs = opts.muportIpfs || MUPORT_IPFS;
    this._pubkeys = {
      spaces: {}
    };
    this._keystore = keystore;
    var threeIdResolver = get3IdResolver(ipfs, {
      pin: true
    });
    var muportResolver = getMuportResolver(ipfs);
    var resolver = new Resolver(_objectSpread(_objectSpread({}, threeIdResolver), muportResolver));
    OdbIdentityProvider.setDidResolver(resolver);
  }

  (0, _createClass2["default"])(ThreeId, [{
    key: "startUpdatePolling",
    value: function startUpdatePolling() {
      var _this = this;

      if (this._has3idProv) {
        var poll = /*#__PURE__*/function () {
          var _ref = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(method, event) {
            var result;
            return _regenerator["default"].wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return utils.callRpc(_this._provider, method);

                  case 2:
                    result = _context.sent;
                    result.map(function (data) {
                      _this.events.emit(event, data);
                    });

                  case 4:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          }));

          return function poll(_x, _x2) {
            return _ref.apply(this, arguments);
          };
        }();

        this._pollInterval = setInterval(function () {
          poll('3id_newAuthMethodPoll', 'new-auth-method');
          poll('3id_newLinkPoll', 'new-link-proof');
        }, POLL_INTERVAL);
      }
    }
  }, {
    key: "signJWT",
    value: function () {
      var _signJWT = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(payload) {
        var _ref2,
            space,
            expiresIn,
            issuer,
            keyring,
            settings,
            _args2 = arguments;

        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _ref2 = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {}, space = _ref2.space, expiresIn = _ref2.expiresIn;
                issuer = this.DID;

                if (space) {
                  issuer = this._subDIDs[space];
                }

                if (!this._has3idProv) {
                  _context2.next = 7;
                  break;
                }

                return _context2.abrupt("return", utils.callRpc(this._provider, '3id_signClaim', {
                  payload: payload,
                  did: issuer,
                  space: space,
                  expiresIn: expiresIn
                }));

              case 7:
                keyring = this._keyringBySpace(space);
                settings = {
                  signer: keyring.getJWTSigner(),
                  issuer: issuer,
                  expiresIn: expiresIn
                };
                return _context2.abrupt("return", didJWT.createJWT(payload, settings));

              case 10:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function signJWT(_x3) {
        return _signJWT.apply(this, arguments);
      }

      return signJWT;
    }()
  }, {
    key: "getSubDID",
    value: function getSubDID(space) {
      return this._subDIDs[space];
    }
  }, {
    key: "getOdbId",
    value: function () {
      var _getOdbId = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(space) {
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                return _context3.abrupt("return", Identities.createIdentity({
                  type: '3ID',
                  threeId: this,
                  space: space,
                  keystore: this._keystore
                }));

              case 1:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getOdbId(_x4) {
        return _getOdbId.apply(this, arguments);
      }

      return getOdbId;
    }()
  }, {
    key: "serializeState",
    value: function serializeState() {
      var _this2 = this;

      if (this._has3idProv) throw new Error('Can not serializeState of IdentityWallet');
      var stateObj = {
        managementAddress: this.managementAddress,
        seed: this._mainKeyring.serialize(),
        spaceSeeds: {}
      };
      Object.keys(this._keyrings).map(function (name) {
        stateObj.spaceSeeds[name] = _this2._keyrings[name].serialize();
      });
      return JSON.stringify(stateObj);
    }
  }, {
    key: "_initKeys",
    value: function _initKeys(serializedState) {
      var _this3 = this;

      if (this._has3idProv) throw new Error('Can not initKeys of IdentityWallet');
      this._keyrings = {};
      var state = JSON.parse(serializedState); // TODO remove toLowerCase() in future, should be sanitized elsewhere
      //      this forces existing state to correct state so that address <->
      //      rootstore relation holds

      this.managementAddress = state.managementAddress.toLowerCase();
      this._mainKeyring = new Keyring(state.seed);
      Object.keys(state.spaceSeeds).map(function (name) {
        _this3._keyrings[name] = new Keyring(state.spaceSeeds[name]);
      });
      localstorage.set(STORAGE_KEY + this.managementAddress, this.serializeState());
    }
  }, {
    key: "_initDID",
    value: function () {
      var _initDID2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4() {
        var _this4 = this;

        var muportPromise, spaces, subDIDs;
        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                muportPromise = this._initMuport();
                _context4.next = 3;
                return this._init3ID();

              case 3:
                this._rootDID = _context4.sent;

                if (this._has3idProv) {
                  spaces = Object.keys(this._pubkeys.spaces);
                } else {
                  spaces = Object.keys(this._keyrings);
                }

                _context4.next = 7;
                return Promise.all(spaces.map(function (space) {
                  return _this4._init3ID(space);
                }));

              case 7:
                subDIDs = _context4.sent;
                this._subDIDs = {};
                spaces.map(function (space, i) {
                  _this4._subDIDs[space] = subDIDs[i];
                });
                _context4.next = 12;
                return muportPromise;

              case 12:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function _initDID() {
        return _initDID2.apply(this, arguments);
      }

      return _initDID;
    }()
  }, {
    key: "_init3ID",
    value: function () {
      var _init3ID2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee5(spaceName) {
        var doc, pubkeys, payload, signature;
        return _regenerator["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                doc = new DidDocument(this._ipfs, DID_METHOD_NAME);
                _context5.next = 3;
                return this.getPublicKeys(spaceName, true);

              case 3:
                pubkeys = _context5.sent;

                if (spaceName) {
                  _context5.next = 11;
                  break;
                }

                doc.addPublicKey('signingKey', 'Secp256k1VerificationKey2018', 'publicKeyHex', pubkeys.signingKey);
                doc.addPublicKey('encryptionKey', 'Curve25519EncryptionPublicKey', 'publicKeyBase64', pubkeys.asymEncryptionKey);
                doc.addPublicKey('managementKey', 'Secp256k1VerificationKey2018', 'ethereumAddress', pubkeys.managementKey);
                doc.addAuthentication('Secp256k1SignatureAuthentication2018', 'signingKey');
                _context5.next = 21;
                break;

              case 11:
                doc.addPublicKey('subSigningKey', 'Secp256k1VerificationKey2018', 'publicKeyHex', pubkeys.signingKey);
                doc.addPublicKey('subEncryptionKey', 'Curve25519EncryptionPublicKey', 'publicKeyBase64', pubkeys.asymEncryptionKey);
                doc.addAuthentication('Secp256k1SignatureAuthentication2018', 'subSigningKey');
                doc.addCustomProperty('space', spaceName);
                doc.addCustomProperty('root', this.DID);
                payload = {
                  iat: null,
                  subSigningKey: pubkeys.signingKey,
                  subEncryptionKey: pubkeys.asymEncryptionKey,
                  space: spaceName
                };
                _context5.next = 19;
                return this.signJWT(payload, {
                  use3ID: true
                });

              case 19:
                signature = _context5.sent.split('.')[2];
                doc.addCustomProperty('proof', {
                  alg: 'ES256K',
                  signature: signature
                });

              case 21:
                _context5.next = 23;
                return doc.commit({
                  noTimestamp: true
                });

              case 23:
                return _context5.abrupt("return", doc.DID);

              case 24:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function _init3ID(_x5) {
        return _init3ID2.apply(this, arguments);
      }

      return _init3ID;
    }()
  }, {
    key: "_initMuport",
    value: function () {
      var _initMuport2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee6() {
        var keys, doc, serializedDoc, generator, docCid;
        return _regenerator["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this.getPublicKeys(null);

              case 2:
                keys = _context6.sent;
                doc = createMuportDocument(keys.signingKey, keys.managementKey, keys.asymEncryptionKey);
                serializedDoc = Buffer.from(JSON.stringify(doc));
                _context6.next = 7;
                return this._ipfs.add(serializedDoc);

              case 7:
                generator = _context6.sent;
                _context6.next = 10;
                return generator.next();

              case 10:
                docCid = _context6.sent.value.cid;
                _context6.next = 13;
                return generator.next();

              case 13:
                // we need to do this in order to not block the process in tests
                this._muportDID = 'did:muport:' + docCid.toString();
                this.muportFingerprint = utils.sha256Multihash(this.muportDID);

              case 15:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function _initMuport() {
        return _initMuport2.apply(this, arguments);
      }

      return _initMuport;
    }()
  }, {
    key: "getAddress",
    value: function () {
      var _getAddress = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee7() {
        return _regenerator["default"].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (!this._has3idProv) {
                  _context7.next = 4;
                  break;
                }

                return _context7.abrupt("return", utils.callRpc(this._provider, '3id_getLink'));

              case 4:
                return _context7.abrupt("return", this.managementAddress);

              case 5:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function getAddress() {
        return _getAddress.apply(this, arguments);
      }

      return getAddress;
    }()
  }, {
    key: "authenticate",
    value: function () {
      var _authenticate = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee8(spaces) {
        var opts,
            pubkeys,
            _iterator,
            _step,
            space,
            _iterator2,
            _step2,
            _space,
            _args8 = arguments;

        return _regenerator["default"].wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                opts = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : {};
                spaces = spaces || [];

                if (!this._has3idProv) {
                  _context8.next = 34;
                  break;
                }

                _context8.next = 5;
                return utils.callRpc(this._provider, '3id_authenticate', {
                  spaces: spaces,
                  authData: opts.authData,
                  address: opts.address
                });

              case 5:
                pubkeys = _context8.sent;
                this._pubkeys.main = pubkeys.main;
                this._pubkeys.spaces = Object.assign(this._pubkeys.spaces, pubkeys.spaces);

                if (this.DID) {
                  _context8.next = 13;
                  break;
                }

                _context8.next = 11;
                return this._initDID();

              case 11:
                _context8.next = 32;
                break;

              case 13:
                _iterator = _createForOfIteratorHelper(spaces);
                _context8.prev = 14;

                _iterator.s();

              case 16:
                if ((_step = _iterator.n()).done) {
                  _context8.next = 24;
                  break;
                }

                space = _step.value;

                if (this._subDIDs[space]) {
                  _context8.next = 22;
                  break;
                }

                _context8.next = 21;
                return this._init3ID(space);

              case 21:
                this._subDIDs[space] = _context8.sent;

              case 22:
                _context8.next = 16;
                break;

              case 24:
                _context8.next = 29;
                break;

              case 26:
                _context8.prev = 26;
                _context8.t0 = _context8["catch"](14);

                _iterator.e(_context8.t0);

              case 29:
                _context8.prev = 29;

                _iterator.f();

                return _context8.finish(29);

              case 32:
                _context8.next = 51;
                break;

              case 34:
                _iterator2 = _createForOfIteratorHelper(spaces);
                _context8.prev = 35;

                _iterator2.s();

              case 37:
                if ((_step2 = _iterator2.n()).done) {
                  _context8.next = 43;
                  break;
                }

                _space = _step2.value;
                _context8.next = 41;
                return this._initKeyringByName(_space);

              case 41:
                _context8.next = 37;
                break;

              case 43:
                _context8.next = 48;
                break;

              case 45:
                _context8.prev = 45;
                _context8.t1 = _context8["catch"](35);

                _iterator2.e(_context8.t1);

              case 48:
                _context8.prev = 48;

                _iterator2.f();

                return _context8.finish(48);

              case 51:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this, [[14, 26, 29, 32], [35, 45, 48, 51]]);
      }));

      function authenticate(_x6) {
        return _authenticate.apply(this, arguments);
      }

      return authenticate;
    }()
  }, {
    key: "isAuthenticated",
    value: function () {
      var _isAuthenticated = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee9() {
        var _this5 = this;

        var spaces,
            _args9 = arguments;
        return _regenerator["default"].wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                spaces = _args9.length > 0 && _args9[0] !== undefined ? _args9[0] : [];
                return _context9.abrupt("return", spaces.reduce(function (acc, space) {
                  return acc && Object.keys(_this5._subDIDs).includes(space);
                }, true));

              case 2:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9);
      }));

      function isAuthenticated() {
        return _isAuthenticated.apply(this, arguments);
      }

      return isAuthenticated;
    }()
  }, {
    key: "_initKeyringByName",
    value: function () {
      var _initKeyringByName2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee10(name) {
        var sig, entropy, seed;
        return _regenerator["default"].wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                if (!this._has3idProv) {
                  _context10.next = 2;
                  break;
                }

                throw new Error('Can not initKeyringByName of IdentityWallet');

              case 2:
                if (this._keyrings[name]) {
                  _context10.next = 16;
                  break;
                }

                _context10.next = 5;
                return utils.openSpaceConsent(this.managementAddress, this._provider, name);

              case 5:
                sig = _context10.sent;
                entropy = '0x' + utils.sha256(sig.slice(2));
                seed = mnemonicToSeed(entropyToMnemonic(entropy));
                this._keyrings[name] = new Keyring(seed);
                _context10.next = 11;
                return this._init3ID(name);

              case 11:
                this._subDIDs[name] = _context10.sent;
                localstorage.set(STORAGE_KEY + this.managementAddress, this.serializeState());
                return _context10.abrupt("return", true);

              case 16:
                return _context10.abrupt("return", false);

              case 17:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function _initKeyringByName(_x7) {
        return _initKeyringByName2.apply(this, arguments);
      }

      return _initKeyringByName;
    }()
  }, {
    key: "getPublicKeys",
    value: function () {
      var _getPublicKeys = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee11(space, uncompressed) {
        var pubkeys;
        return _regenerator["default"].wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                if (this._has3idProv) {
                  pubkeys = Object.assign({}, space ? this._pubkeys.spaces[space] : this._pubkeys.main);

                  if (uncompressed) {
                    pubkeys.signingKey = Keyring.uncompress(pubkeys.signingKey);
                  }
                } else {
                  pubkeys = this._keyringBySpace(space).getPublicKeys(uncompressed);
                  pubkeys.managementKey = this.managementAddress;
                }

                return _context11.abrupt("return", pubkeys);

              case 2:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function getPublicKeys(_x8, _x9) {
        return _getPublicKeys.apply(this, arguments);
      }

      return getPublicKeys;
    }()
  }, {
    key: "encrypt",
    value: function () {
      var _encrypt = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee12(message, space, to) {
        var keyring, paddedMsg;
        return _regenerator["default"].wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                if (!this._has3idProv) {
                  _context12.next = 4;
                  break;
                }

                return _context12.abrupt("return", utils.callRpc(this._provider, '3id_encrypt', {
                  message: message,
                  space: space,
                  to: to
                }));

              case 4:
                keyring = this._keyringBySpace(space);
                paddedMsg = typeof message === 'string' ? utils.pad(message) : message;

                if (!to) {
                  _context12.next = 10;
                  break;
                }

                return _context12.abrupt("return", keyring.asymEncrypt(paddedMsg, to));

              case 10:
                return _context12.abrupt("return", keyring.symEncrypt(paddedMsg));

              case 11:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function encrypt(_x10, _x11, _x12) {
        return _encrypt.apply(this, arguments);
      }

      return encrypt;
    }()
  }, {
    key: "decrypt",
    value: function () {
      var _decrypt = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee13(encObj, space, toBuffer) {
        var res, keyring, paddedMsg;
        return _regenerator["default"].wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                if (!this._has3idProv) {
                  _context13.next = 7;
                  break;
                }

                _context13.next = 3;
                return utils.callRpc(this._provider, '3id_decrypt', _objectSpread(_objectSpread({}, encObj), {}, {
                  space: space,
                  buffer: toBuffer
                }));

              case 3:
                res = _context13.sent;
                return _context13.abrupt("return", toBuffer ? Buffer.from(res) : res);

              case 7:
                keyring = this._keyringBySpace(space);

                if (encObj.ephemeralFrom) {
                  paddedMsg = keyring.asymDecrypt(encObj.ciphertext, encObj.ephemeralFrom, encObj.nonce, toBuffer);
                } else {
                  paddedMsg = keyring.symDecrypt(encObj.ciphertext, encObj.nonce, toBuffer);
                }

                return _context13.abrupt("return", toBuffer ? paddedMsg : utils.unpad(paddedMsg));

              case 10:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function decrypt(_x13, _x14, _x15) {
        return _decrypt.apply(this, arguments);
      }

      return decrypt;
    }()
  }, {
    key: "hashDBKey",
    value: function () {
      var _hashDBKey = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee14(key, space) {
        var salt;
        return _regenerator["default"].wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                if (!this._has3idProv) {
                  _context14.next = 4;
                  break;
                }

                return _context14.abrupt("return", utils.callRpc(this._provider, '3id_hashEntryKey', {
                  key: key,
                  space: space
                }));

              case 4:
                salt = this._keyringBySpace(space).getDBSalt();
                return _context14.abrupt("return", utils.sha256Multihash(salt + key));

              case 6:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function hashDBKey(_x16, _x17) {
        return _hashDBKey.apply(this, arguments);
      }

      return hashDBKey;
    }()
  }, {
    key: "_keyringBySpace",
    value: function _keyringBySpace(space) {
      return space ? this._keyrings[space] : this._mainKeyring;
    }
  }, {
    key: "logout",
    value: function logout() {
      this._rootDID = null;
      this._subDIDs = {};
      localstorage.remove(STORAGE_KEY + this.managementAddress);
      this.stopUpdatePolling();
    }
  }, {
    key: "stopUpdatePolling",
    value: function stopUpdatePolling() {
      if (this._pollInterval) {
        clearInterval(this._pollInterval);
      }
    }
  }, {
    key: "DID",
    get: function get() {
      return this._rootDID;
    }
  }, {
    key: "muportDID",
    get: function get() {
      return this._muportDID;
    }
  }], [{
    key: "isLoggedIn",
    value: function isLoggedIn(address) {
      return Boolean(localstorage.get(STORAGE_KEY + address.toLowerCase()));
    }
  }, {
    key: "getIdFromEthAddress",
    value: function () {
      var _getIdFromEthAddress = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee15(address, provider, ipfs, keystore) {
        var opts,
            normalizedAddress,
            serialized3id,
            sig,
            entropy,
            mnemonic,
            seed,
            threeId,
            _args15 = arguments;
        return _regenerator["default"].wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                opts = _args15.length > 4 && _args15[4] !== undefined ? _args15[4] : {};
                opts.has3idProv = Boolean(provider.is3idProvider);

                if (!opts.has3idProv) {
                  _context15.next = 6;
                  break;
                }

                return _context15.abrupt("return", new ThreeId(provider, ipfs, keystore, opts));

              case 6:
                normalizedAddress = address.toLowerCase();
                serialized3id = localstorage.get(STORAGE_KEY + normalizedAddress);

                if (!serialized3id) {
                  _context15.next = 12;
                  break;
                }

                if (opts.consentCallback) opts.consentCallback(false);
                _context15.next = 24;
                break;

              case 12:
                if (!opts.contentSignature) {
                  _context15.next = 16;
                  break;
                }

                sig = opts.contentSignature;
                _context15.next = 19;
                break;

              case 16:
                _context15.next = 18;
                return utils.openBoxConsent(normalizedAddress, provider);

              case 18:
                sig = _context15.sent;

              case 19:
                if (opts.consentCallback) opts.consentCallback(true);
                entropy = '0x' + utils.sha256(sig.slice(2));
                mnemonic = entropyToMnemonic(entropy);
                seed = mnemonicToSeed(mnemonic);
                serialized3id = JSON.stringify({
                  managementAddress: normalizedAddress,
                  seed: seed,
                  spaceSeeds: {}
                });

              case 24:
                threeId = new ThreeId(provider, ipfs, keystore, opts);

                threeId._initKeys(serialized3id);

                _context15.next = 28;
                return threeId._initDID();

              case 28:
                return _context15.abrupt("return", threeId);

              case 29:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15);
      }));

      function getIdFromEthAddress(_x18, _x19, _x20, _x21) {
        return _getIdFromEthAddress.apply(this, arguments);
      }

      return getIdFromEthAddress;
    }()
  }]);
  return ThreeId;
}();

var createMuportDocument = function createMuportDocument(signingKey, managementKey, asymEncryptionKey) {
  return {
    version: 1,
    signingKey: signingKey,
    managementKey: managementKey,
    asymEncryptionKey: asymEncryptionKey
  };
};

module.exports = ThreeId;