"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var KeyValueStore = require('./keyValueStore');

var Thread = require('./thread');

var GhostThread = require('./ghost');

var API = require('./api');

var _require = require('./utils'),
    throwIfUndefined = _require.throwIfUndefined,
    throwIfNotEqualLenArrays = _require.throwIfNotEqualLenArrays;

var OrbitDBAddress = require('orbit-db/src/orbit-db-address');

var nameToSpaceName = function nameToSpaceName(name) {
  return "3box.space.".concat(name, ".keyvalue");
};

var namesTothreadName = function namesTothreadName(spaceName, threadName) {
  return "3box.thread.".concat(spaceName, ".").concat(threadName);
};

var namesToChatName = function namesToChatName(spaceName, chatName) {
  return "3box.ghost.".concat(spaceName, ".").concat(chatName);
};
/** Class representing a user. */


var User = /*#__PURE__*/function () {
  function User(spaceName, threeId, resolver) {
    (0, _classCallCheck2["default"])(this, User);
    this._name = spaceName;
    this._3id = threeId;
    this._resolver = resolver;
  }
  /**
   * @property {String} DID            the DID of the user
   */


  (0, _createClass2["default"])(User, [{
    key: "signClaim",

    /**
     * Sign a JWT claim
     *
     * @param     {Object}    payload                 The payload to sign
     * @param     {Object}    opts                    Optional parameters
     *
     * @return    {String}                            The signed JWT
     */
    value: function () {
      var _signClaim = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(payload) {
        var opts,
            _args = arguments;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                opts = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
                return _context.abrupt("return", this._3id.signJWT(payload, Object.assign(opts, {
                  space: this._name
                })));

              case 2:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function signClaim(_x) {
        return _signClaim.apply(this, arguments);
      }

      return signClaim;
    }()
    /**
     * Encrypt a message. By default encrypts messages symmetrically
     * with the users private key. If the `to` parameter is used,
     * the message will be asymmetrically encrypted to the recipient.
     *
     * @param     {String}    message                 The message to encrypt
     * @param     {Object}    opts                    Optional parameters
     * @param     {String}    to                      The receiver of the message, a DID or an ethereum address
     *
     * @return    {Object}                            An object containing the encrypted payload
     */

  }, {
    key: "encrypt",
    value: function () {
      var _encrypt = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(message) {
        var _ref,
            to,
            toPubkey,
            _args2 = arguments;

        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _ref = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {}, to = _ref.to;

                if (!to) {
                  _context2.next = 5;
                  break;
                }

                _context2.next = 4;
                return this._findSpacePubKey(to, this._name);

              case 4:
                toPubkey = _context2.sent;

              case 5:
                return _context2.abrupt("return", this._3id.encrypt(message, this._name, toPubkey));

              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function encrypt(_x2) {
        return _encrypt.apply(this, arguments);
      }

      return encrypt;
    }()
    /**
     * Decrypts a message if the user owns the correct key to decrypt it.
     *
     * @param     {Object}    encryptedObject         The encrypted message to decrypt (as encoded by the `encrypt` method
     *
     * @return    {String}                            The clear text message
     */

  }, {
    key: "decrypt",
    value: function () {
      var _decrypt = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(encryptedObject, toBuffer) {
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                return _context3.abrupt("return", this._3id.decrypt(encryptedObject, this._name, toBuffer));

              case 1:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function decrypt(_x3, _x4) {
        return _decrypt.apply(this, arguments);
      }

      return decrypt;
    }()
  }, {
    key: "_findSpacePubKey",
    value: function () {
      var _findSpacePubKey2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4(did, spaceName) {
        var doc, pubkey;
        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (!did.startsWith('0x')) {
                  _context4.next = 4;
                  break;
                }

                _context4.next = 3;
                return API.getSpaceDID(did, spaceName);

              case 3:
                did = _context4.sent;

              case 4:
                _context4.next = 6;
                return this._resolver.resolve(did);

              case 6:
                doc = _context4.sent;
                pubkey = doc.publicKey.find(function (key) {
                  return key.id.includes('#subEncryptionKey');
                });

                if (pubkey) {
                  _context4.next = 16;
                  break;
                }

                _context4.next = 11;
                return API.getSpaceDID(did, spaceName);

              case 11:
                did = _context4.sent;
                _context4.next = 14;
                return this._resolver.resolve(did);

              case 14:
                doc = _context4.sent;
                pubkey = doc.publicKey.find(function (key) {
                  return key.id.includes('#subEncryptionKey');
                });

              case 16:
                return _context4.abrupt("return", pubkey.publicKeyBase64);

              case 17:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function _findSpacePubKey(_x5, _x6) {
        return _findSpacePubKey2.apply(this, arguments);
      }

      return _findSpacePubKey;
    }()
  }, {
    key: "DID",
    get: function get() {
      return this._3id.getSubDID(this._name);
    }
  }]);
  return User;
}();

var Space = /*#__PURE__*/function () {
  /**
   * Please use **box.openSpace** to get the instance of this class
   */
  function Space(name, replicator) {
    (0, _classCallCheck2["default"])(this, Space);
    this._name = name;
    this._replicator = replicator;
    this._store = new KeyValueStore(nameToSpaceName(this._name), this._replicator);
    this._activeThreads = {};
    /**
     * @property {KeyValueStore} public         access the profile store of the space
     */

    this["public"] = null;
    /**
     * @property {KeyValueStore} private        access the private store of the space
     */

    this["private"] = null;
    /**
     * @property {Promise}       syncDone       A promise that is resolved when the space data is synced
     */

    this.syncDone = null;
  }

  (0, _createClass2["default"])(Space, [{
    key: "open",
    value: function () {
      var _open = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee6(threeId) {
        var _this = this;

        var opts,
            authenticated,
            syncSpace,
            _args6 = arguments;
        return _regenerator["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                opts = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : {};

                if (this.isOpen) {
                  _context6.next = 18;
                  break;
                }

                // store is not loaded opened yet
                this._3id = threeId;
                _context6.next = 5;
                return this._3id.isAuthenticated([this._name]);

              case 5:
                authenticated = _context6.sent;

                if (authenticated) {
                  _context6.next = 9;
                  break;
                }

                _context6.next = 9;
                return this._3id.authenticate([this._name], opts);

              case 9:
                if (opts.consentCallback) opts.consentCallback(!authenticated, this._name);
                _context6.next = 12;
                return this._store._load(this._3id);

              case 12:
                syncSpace = /*#__PURE__*/function () {
                  var _ref2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee5() {
                    return _regenerator["default"].wrap(function _callee5$(_context5) {
                      while (1) {
                        switch (_context5.prev = _context5.next) {
                          case 0:
                            _context5.next = 2;
                            return _this._store._sync();

                          case 2:
                            if (opts.onSyncDone) opts.onSyncDone();

                          case 3:
                          case "end":
                            return _context5.stop();
                        }
                      }
                    }, _callee5);
                  }));

                  return function syncSpace() {
                    return _ref2.apply(this, arguments);
                  };
                }();

                this.syncDone = syncSpace();
                this["public"] = publicStoreReducer(this._store);
                this["private"] = privateStoreReducer(this._store, this._3id, this._name); // make sure we're authenticated to all threads

                _context6.next = 18;
                return this._authThreads(this._3id);

              case 18:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function open(_x7) {
        return _open.apply(this, arguments);
      }

      return open;
    }()
  }, {
    key: "_authThreads",
    value: function () {
      var _authThreads2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee7(threeId) {
        var odbIdentity;
        return _regenerator["default"].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return threeId.getOdbId(this._name);

              case 2:
                odbIdentity = _context7.sent;
                Object.values(this._activeThreads).forEach(function (thread) {
                  if (thread.isGhost) {
                    thread._set3id(threeId);
                  } else {
                    thread._setIdentity(odbIdentity);
                  }
                });

              case 4:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function _authThreads(_x8) {
        return _authThreads2.apply(this, arguments);
      }

      return _authThreads;
    }()
    /**
     * Join a thread. Use this to start receiving updates from, and to post in threads
     *
     * @param     {String}    name                    The name of the thread
     * @param     {Object}    opts                    Optional parameters
     * @param     {String}    opts.firstModerator     DID of first moderator of a thread, by default, user is first moderator
     * @param     {Boolean}   opts.members            join a members only thread, which only members can post in, defaults to open thread
     * @param     {Boolean}   opts.confidential       create a confidential thread with true or join existing confidential thread with an encKeyId string
     * @param     {Boolean}   opts.noAutoSub          Disable auto subscription to the thread when posting to it (default false)
     * @param     {Boolean}   opts.ghost              Enable ephemeral messaging via Ghost Thread
     * @param     {String}    opts.ghostPinbot        MultiAddress of a Ghost Pinbot node
     * @param     {Number}    opts.ghostBacklogLimit  The number of posts to maintain in the ghost backlog
     * @param     {Array<Function>} opts.ghostFilters Array of functions for filtering messages
     *
     * @return    {Thread}                  An instance of the thread class for the joined thread
     */

  }, {
    key: "joinThread",
    value: function () {
      var _joinThread = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee8(name) {
        var opts,
            ghostAddress,
            subscribeFn,
            user,
            thread,
            address,
            _args8 = arguments;
        return _regenerator["default"].wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                opts = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : {};

                if (!opts.ghost) {
                  _context8.next = 8;
                  break;
                }

                ghostAddress = namesToChatName(this._name, name);

                if (!this._activeThreads[ghostAddress]) {
                  this._activeThreads[ghostAddress] = new GhostThread(ghostAddress, this._replicator, this._3id, opts);
                }

                if (this._3id) {
                  this._activeThreads[ghostAddress]._set3id(this._3id);
                }

                return _context8.abrupt("return", this._activeThreads[ghostAddress]);

              case 8:
                subscribeFn = opts.noAutoSub ? function () {} : this.subscribeThread.bind(this);

                if (!opts.confidential) {
                  _context8.next = 12;
                  break;
                }

                if (this._3id) {
                  _context8.next = 12;
                  break;
                }

                throw new Error('confidential threads require user to be authenticated');

              case 12:
                if (opts.firstModerator) {
                  _context8.next = 16;
                  break;
                }

                if (this._3id) {
                  _context8.next = 15;
                  break;
                }

                throw new Error('firstModerator required if not authenticated');

              case 15:
                opts.firstModerator = this._3id.getSubDID(this._name);

              case 16:
                user = this._3id ? this.user : {};
                thread = new Thread(namesTothreadName(this._name, name), this._replicator, opts.members, opts.firstModerator, opts.confidential, user, subscribeFn);
                _context8.next = 20;
                return thread._getThreadAddress();

              case 20:
                address = _context8.sent;

                if (!this._activeThreads[address]) {
                  _context8.next = 23;
                  break;
                }

                return _context8.abrupt("return", this._activeThreads[address]);

              case 23:
                _context8.next = 25;
                return thread._load();

              case 25:
                if (!this._3id) {
                  _context8.next = 32;
                  break;
                }

                _context8.t0 = thread;
                _context8.next = 29;
                return this._3id.getOdbId(this._name);

              case 29:
                _context8.t1 = _context8.sent;
                _context8.next = 32;
                return _context8.t0._setIdentity.call(_context8.t0, _context8.t1);

              case 32:
                this._activeThreads[address] = thread;
                return _context8.abrupt("return", thread);

              case 34:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function joinThread(_x9) {
        return _joinThread.apply(this, arguments);
      }

      return joinThread;
    }()
    /**
     * Create a confidential thread
     *
     * @param     {String}    name          The name of the thread
     *
     * @return    {Thread}                  An instance of the thread class for the created thread
     */

  }, {
    key: "createConfidentialThread",
    value: function () {
      var _createConfidentialThread = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee9(name) {
        return _regenerator["default"].wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                return _context9.abrupt("return", this.joinThread(name, {
                  confidential: true
                }));

              case 1:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function createConfidentialThread(_x10) {
        return _createConfidentialThread.apply(this, arguments);
      }

      return createConfidentialThread;
    }()
    /**
     * Join a thread by full thread address. Use this to start receiving updates from, and to post in threads
     *
     * @param     {String}    address                 The full address of the thread
     * @param     {Object}    opts                    Optional parameters
     * @param     {Boolean}   opts.noAutoSub          Disable auto subscription to the thread when posting to it (default false)
     *
     * @return    {Thread}                            An instance of the thread class for the joined thread
     */

  }, {
    key: "joinThreadByAddress",
    value: function () {
      var _joinThreadByAddress = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee10(address) {
        var opts,
            threadSpace,
            threadName,
            subscribeFn,
            user,
            thread,
            _args10 = arguments;
        return _regenerator["default"].wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                opts = _args10.length > 1 && _args10[1] !== undefined ? _args10[1] : {};

                if (OrbitDBAddress.isValid(address)) {
                  _context10.next = 3;
                  break;
                }

                throw new Error('joinThreadByAddress: valid orbitdb address required');

              case 3:
                if (this.isOpen) {
                  _context10.next = 5;
                  break;
                }

                throw new Error('joinThreadByAddress requires space to be open');

              case 5:
                threadSpace = address.split('.')[2];
                threadName = address.split('.')[3];

                if (!(threadSpace !== this._name)) {
                  _context10.next = 9;
                  break;
                }

                throw new Error('joinThreadByAddress: attempting to open thread from different space, must open within same space');

              case 9:
                if (!this._activeThreads[address]) {
                  _context10.next = 11;
                  break;
                }

                return _context10.abrupt("return", this._activeThreads[address]);

              case 11:
                subscribeFn = opts.noAutoSub ? function () {} : this.subscribeThread.bind(this);
                user = this._3id ? this.user : {};
                thread = new Thread(namesTothreadName(this._name, threadName), this._replicator, undefined, undefined, undefined, user, subscribeFn);
                _context10.next = 16;
                return thread._load(address);

              case 16:
                if (!this._3id) {
                  _context10.next = 23;
                  break;
                }

                _context10.t0 = thread;
                _context10.next = 20;
                return this._3id.getOdbId(this._name);

              case 20:
                _context10.t1 = _context10.sent;
                _context10.next = 23;
                return _context10.t0._setIdentity.call(_context10.t0, _context10.t1);

              case 23:
                this._activeThreads[address] = thread;
                return _context10.abrupt("return", thread);

              case 25:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function joinThreadByAddress(_x11) {
        return _joinThreadByAddress.apply(this, arguments);
      }

      return joinThreadByAddress;
    }()
    /**
     * Subscribe to the given thread, if not already subscribed
     *
     * @param     {String}    address                The address of the thread
     * @param     {Object}    config                configuration and thread meta data
     * @param     {String}    opts.name             Name of thread
     * @param     {String}    opts.firstModerator   DID of the first moderator
     * @param     {String}    opts.members          Boolean string, true if a members only thread
     */

  }, {
    key: "subscribeThread",
    value: function () {
      var _subscribeThread = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee11(address) {
        var config,
            threadKey,
            _args11 = arguments;
        return _regenerator["default"].wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                config = _args11.length > 1 && _args11[1] !== undefined ? _args11[1] : {};

                if (OrbitDBAddress.isValid(address)) {
                  _context11.next = 3;
                  break;
                }

                throw new Error('subscribeThread: must subscribe to valid thread/orbitdb address');

              case 3:
                if (this.isOpen) {
                  _context11.next = 5;
                  break;
                }

                return _context11.abrupt("return");

              case 5:
                // we can't subscribe if space isn't open
                threadKey = "thread-".concat(address);
                _context11.next = 8;
                return this.syncDone;

              case 8:
                _context11.next = 10;
                return this["public"].get(threadKey);

              case 10:
                if (_context11.sent) {
                  _context11.next = 13;
                  break;
                }

                _context11.next = 13;
                return this["public"].set(threadKey, Object.assign({}, config, {
                  address: address
                }));

              case 13:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function subscribeThread(_x12) {
        return _subscribeThread.apply(this, arguments);
      }

      return subscribeThread;
    }()
    /**
     * Unsubscribe from the given thread, if subscribed
     *
     * @param     {String}    address     The address of the thread
     */

  }, {
    key: "unsubscribeThread",
    value: function () {
      var _unsubscribeThread = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee12(address) {
        var threadKey;
        return _regenerator["default"].wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                if (this.isOpen) {
                  _context12.next = 2;
                  break;
                }

                throw new Error('unsubscribeThread requires space to be open');

              case 2:
                threadKey = "thread-".concat(address);
                _context12.next = 5;
                return this["public"].get(threadKey);

              case 5:
                if (!_context12.sent) {
                  _context12.next = 8;
                  break;
                }

                _context12.next = 8;
                return this["public"].remove(threadKey);

              case 8:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function unsubscribeThread(_x13) {
        return _unsubscribeThread.apply(this, arguments);
      }

      return unsubscribeThread;
    }()
    /**
     * Get a list of all the threads subscribed to in this space
     *
     * @return    {Array<Objects>}    A list of thread objects as { address, firstModerator, members, name}
     */

  }, {
    key: "subscribedThreads",
    value: function () {
      var _subscribedThreads = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee13() {
        var allEntries;
        return _regenerator["default"].wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                if (this.isOpen) {
                  _context13.next = 2;
                  break;
                }

                throw new Error('subscribedThreads requires space to be open');

              case 2:
                _context13.next = 4;
                return this["public"].all();

              case 4:
                allEntries = _context13.sent;
                return _context13.abrupt("return", Object.keys(allEntries).reduce(function (threads, key) {
                  if (key.startsWith('thread')) {
                    // ignores experimental threads (v1)
                    var address = key.split('thread-')[1];

                    if (OrbitDBAddress.isValid(address)) {
                      threads.push(allEntries[key]);
                    }
                  }

                  return threads;
                }, []));

              case 6:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function subscribedThreads() {
        return _subscribedThreads.apply(this, arguments);
      }

      return subscribedThreads;
    }()
  }, {
    key: "DID",
    get: function get() {
      return this.user.DID;
    }
    /**
     * @property {User} user            access the user object to encrypt data and sign claims
     */

  }, {
    key: "user",
    get: function get() {
      if (!this._3id) throw new Error('user is not authenticated');
      this._user = this._user || new User(this._name, this._3id, this._replicator.resolver);
      return this._user;
    }
  }, {
    key: "isOpen",
    get: function get() {
      return Boolean(this._store._db);
    }
  }]);
  return Space;
}();

module.exports = Space;

var publicStoreReducer = function publicStoreReducer(store) {
  var PREFIX = 'pub_';
  return {
    get: function () {
      var _get = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee14(key) {
        var opts,
            _args14 = arguments;
        return _regenerator["default"].wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                opts = _args14.length > 1 && _args14[1] !== undefined ? _args14[1] : {};
                return _context14.abrupt("return", store.get(PREFIX + key, opts));

              case 2:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14);
      }));

      function get(_x14) {
        return _get.apply(this, arguments);
      }

      return get;
    }(),
    getMetadata: function () {
      var _getMetadata = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee15(key) {
        return _regenerator["default"].wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                return _context15.abrupt("return", store.getMetadata(PREFIX + key));

              case 1:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15);
      }));

      function getMetadata(_x15) {
        return _getMetadata.apply(this, arguments);
      }

      return getMetadata;
    }(),
    set: function () {
      var _set = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee16(key, value) {
        return _regenerator["default"].wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                throwIfUndefined(key, 'key');
                return _context16.abrupt("return", store.set(PREFIX + key, value));

              case 2:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16);
      }));

      function set(_x16, _x17) {
        return _set.apply(this, arguments);
      }

      return set;
    }(),
    setMultiple: function () {
      var _setMultiple = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee17(keys, values) {
        var prefixedKeys;
        return _regenerator["default"].wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                throwIfNotEqualLenArrays(keys, values);
                prefixedKeys = keys.map(function (key) {
                  return PREFIX + key;
                });
                return _context17.abrupt("return", store.setMultiple(prefixedKeys, values));

              case 3:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17);
      }));

      function setMultiple(_x18, _x19) {
        return _setMultiple.apply(this, arguments);
      }

      return setMultiple;
    }(),
    remove: function () {
      var _remove = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee18(key) {
        return _regenerator["default"].wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                throwIfUndefined(key, 'key');
                return _context18.abrupt("return", store.remove(PREFIX + key));

              case 2:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18);
      }));

      function remove(_x20) {
        return _remove.apply(this, arguments);
      }

      return remove;
    }(),
    log: function log() {
      return (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee19() {
        return _regenerator["default"].wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                _context19.next = 2;
                return store.log();

              case 2:
                return _context19.abrupt("return", _context19.sent.reduce(function (newLog, entry) {
                  if (entry.key.startsWith(PREFIX)) {
                    entry.key = entry.key.slice(4);
                    newLog.push(entry);
                  }

                  return newLog;
                }, []));

              case 3:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19);
      }))();
    },
    all: function () {
      var _all = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee20(opts) {
        var entries;
        return _regenerator["default"].wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                _context20.next = 2;
                return store.all(opts);

              case 2:
                entries = _context20.sent;
                return _context20.abrupt("return", Object.keys(entries).reduce(function (newAll, key) {
                  if (key.startsWith(PREFIX)) {
                    newAll[key.slice(4)] = entries[key];
                  }

                  return newAll;
                }, {}));

              case 4:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20);
      }));

      function all(_x21) {
        return _all.apply(this, arguments);
      }

      return all;
    }()
  };
};

var privateStoreReducer = function privateStoreReducer(store, threeId, spaceName) {
  var PREFIX = 'priv_';

  var dbKey = /*#__PURE__*/function () {
    var _ref3 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee21(key) {
      return _regenerator["default"].wrap(function _callee21$(_context21) {
        while (1) {
          switch (_context21.prev = _context21.next) {
            case 0:
              throwIfUndefined(key, 'key');
              _context21.t0 = PREFIX;
              _context21.next = 4;
              return threeId.hashDBKey(key, spaceName);

            case 4:
              _context21.t1 = _context21.sent;
              return _context21.abrupt("return", _context21.t0 + _context21.t1);

            case 6:
            case "end":
              return _context21.stop();
          }
        }
      }, _callee21);
    }));

    return function dbKey(_x22) {
      return _ref3.apply(this, arguments);
    };
  }();

  var encryptEntry = /*#__PURE__*/function () {
    var _ref4 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee22(entry) {
      return _regenerator["default"].wrap(function _callee22$(_context22) {
        while (1) {
          switch (_context22.prev = _context22.next) {
            case 0:
              return _context22.abrupt("return", threeId.encrypt(JSON.stringify(entry), spaceName));

            case 1:
            case "end":
              return _context22.stop();
          }
        }
      }, _callee22);
    }));

    return function encryptEntry(_x23) {
      return _ref4.apply(this, arguments);
    };
  }();

  var decryptEntry = /*#__PURE__*/function () {
    var _ref5 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee23(encObj) {
      return _regenerator["default"].wrap(function _callee23$(_context23) {
        while (1) {
          switch (_context23.prev = _context23.next) {
            case 0:
              _context23.t0 = JSON;
              _context23.next = 3;
              return threeId.decrypt(encObj, spaceName);

            case 3:
              _context23.t1 = _context23.sent;
              return _context23.abrupt("return", _context23.t0.parse.call(_context23.t0, _context23.t1));

            case 5:
            case "end":
              return _context23.stop();
          }
        }
      }, _callee23);
    }));

    return function decryptEntry(_x24) {
      return _ref5.apply(this, arguments);
    };
  }();

  return {
    get: function () {
      var _get2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee24(key) {
        var opts,
            entry,
            _args24 = arguments;
        return _regenerator["default"].wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                opts = _args24.length > 1 && _args24[1] !== undefined ? _args24[1] : {};
                _context24.t0 = store;
                _context24.next = 4;
                return dbKey(key);

              case 4:
                _context24.t1 = _context24.sent;
                _context24.t2 = opts;
                _context24.next = 8;
                return _context24.t0.get.call(_context24.t0, _context24.t1, _context24.t2);

              case 8:
                entry = _context24.sent;

                if (entry) {
                  _context24.next = 11;
                  break;
                }

                return _context24.abrupt("return", null);

              case 11:
                if (!opts.metadata) {
                  _context24.next = 20;
                  break;
                }

                _context24.t3 = _objectSpread;
                _context24.t4 = _objectSpread({}, entry);
                _context24.t5 = {};
                _context24.next = 17;
                return decryptEntry(entry.value);

              case 17:
                _context24.t6 = _context24.sent.value;
                _context24.t7 = {
                  value: _context24.t6
                };
                return _context24.abrupt("return", (0, _context24.t3)(_context24.t4, _context24.t5, _context24.t7));

              case 20:
                _context24.next = 22;
                return decryptEntry(entry);

              case 22:
                return _context24.abrupt("return", _context24.sent.value);

              case 23:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24);
      }));

      function get(_x25) {
        return _get2.apply(this, arguments);
      }

      return get;
    }(),
    getMetadata: function () {
      var _getMetadata2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee25(key) {
        return _regenerator["default"].wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                _context25.t0 = store;
                _context25.next = 3;
                return dbKey(key);

              case 3:
                _context25.t1 = _context25.sent;
                return _context25.abrupt("return", _context25.t0.getMetadata.call(_context25.t0, _context25.t1));

              case 5:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25);
      }));

      function getMetadata(_x26) {
        return _getMetadata2.apply(this, arguments);
      }

      return getMetadata;
    }(),
    set: function () {
      var _set2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee26(key, value) {
        return _regenerator["default"].wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                _context26.t0 = store;
                _context26.next = 3;
                return dbKey(key);

              case 3:
                _context26.t1 = _context26.sent;
                _context26.next = 6;
                return encryptEntry({
                  key: key,
                  value: value
                });

              case 6:
                _context26.t2 = _context26.sent;
                return _context26.abrupt("return", _context26.t0.set.call(_context26.t0, _context26.t1, _context26.t2));

              case 8:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26);
      }));

      function set(_x27, _x28) {
        return _set2.apply(this, arguments);
      }

      return set;
    }(),
    setMultiple: function () {
      var _setMultiple2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee27(keys, values) {
        var dbKeys, encryptedEntries;
        return _regenerator["default"].wrap(function _callee27$(_context27) {
          while (1) {
            switch (_context27.prev = _context27.next) {
              case 0:
                throwIfNotEqualLenArrays(keys, values);
                _context27.next = 3;
                return Promise.all(keys.map(dbKey));

              case 3:
                dbKeys = _context27.sent;
                _context27.next = 6;
                return Promise.all(values.map(function (value, index) {
                  return encryptEntry({
                    key: keys[index],
                    value: value
                  });
                }));

              case 6:
                encryptedEntries = _context27.sent;
                return _context27.abrupt("return", store.setMultiple(dbKeys, encryptedEntries));

              case 8:
              case "end":
                return _context27.stop();
            }
          }
        }, _callee27);
      }));

      function setMultiple(_x29, _x30) {
        return _setMultiple2.apply(this, arguments);
      }

      return setMultiple;
    }(),
    remove: function () {
      var _remove2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee28(key) {
        return _regenerator["default"].wrap(function _callee28$(_context28) {
          while (1) {
            switch (_context28.prev = _context28.next) {
              case 0:
                _context28.t0 = store;
                _context28.next = 3;
                return dbKey(key);

              case 3:
                _context28.t1 = _context28.sent;
                return _context28.abrupt("return", _context28.t0.remove.call(_context28.t0, _context28.t1));

              case 5:
              case "end":
                return _context28.stop();
            }
          }
        }, _callee28);
      }));

      function remove(_x31) {
        return _remove2.apply(this, arguments);
      }

      return remove;
    }(),
    log: function log() {
      return (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee29() {
        var log, privLog, _iterator, _step, entry, decEntry;

        return _regenerator["default"].wrap(function _callee29$(_context29) {
          while (1) {
            switch (_context29.prev = _context29.next) {
              case 0:
                _context29.next = 2;
                return store.log();

              case 2:
                log = _context29.sent;
                privLog = [];
                _iterator = _createForOfIteratorHelper(log);
                _context29.prev = 5;

                _iterator.s();

              case 7:
                if ((_step = _iterator.n()).done) {
                  _context29.next = 18;
                  break;
                }

                entry = _step.value;

                if (!entry.key.startsWith(PREFIX)) {
                  _context29.next = 16;
                  break;
                }

                _context29.next = 12;
                return decryptEntry(entry.value);

              case 12:
                decEntry = _context29.sent;
                entry.key = decEntry.key;
                entry.value = decEntry.value;
                privLog.push(entry);

              case 16:
                _context29.next = 7;
                break;

              case 18:
                _context29.next = 23;
                break;

              case 20:
                _context29.prev = 20;
                _context29.t0 = _context29["catch"](5);

                _iterator.e(_context29.t0);

              case 23:
                _context29.prev = 23;

                _iterator.f();

                return _context29.finish(23);

              case 26:
                return _context29.abrupt("return", privLog);

              case 27:
              case "end":
                return _context29.stop();
            }
          }
        }, _callee29, null, [[5, 20, 23, 26]]);
      }))();
    },
    all: function () {
      var _all2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee30() {
        var opts,
            entries,
            privEntries,
            key,
            entry,
            decEntry,
            _decEntry,
            _args30 = arguments;

        return _regenerator["default"].wrap(function _callee30$(_context30) {
          while (1) {
            switch (_context30.prev = _context30.next) {
              case 0:
                opts = _args30.length > 0 && _args30[0] !== undefined ? _args30[0] : {};
                _context30.next = 3;
                return store.all(opts);

              case 3:
                entries = _context30.sent;
                privEntries = {};
                _context30.t0 = _regenerator["default"].keys(entries);

              case 6:
                if ((_context30.t1 = _context30.t0()).done) {
                  _context30.next = 23;
                  break;
                }

                key = _context30.t1.value;

                if (!key.startsWith(PREFIX)) {
                  _context30.next = 21;
                  break;
                }

                entry = entries[key];

                if (!opts.metadata) {
                  _context30.next = 17;
                  break;
                }

                _context30.next = 13;
                return decryptEntry(entry.value);

              case 13:
                decEntry = _context30.sent;
                privEntries[decEntry.key] = _objectSpread(_objectSpread({}, entry), {}, {
                  value: decEntry.value
                });
                _context30.next = 21;
                break;

              case 17:
                _context30.next = 19;
                return decryptEntry(entry);

              case 19:
                _decEntry = _context30.sent;
                privEntries[_decEntry.key] = _decEntry.value;

              case 21:
                _context30.next = 6;
                break;

              case 23:
                return _context30.abrupt("return", privEntries);

              case 24:
              case "end":
                return _context30.stop();
            }
          }
        }, _callee30);
      }));

      function all() {
        return _all2.apply(this, arguments);
      }

      return all;
    }()
  };
};