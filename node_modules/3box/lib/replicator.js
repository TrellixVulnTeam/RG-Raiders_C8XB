"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var path = require('path');

var EventEmitter = require('events');

var merge = require('lodash.merge');

var pTimeout = require('p-timeout');

var multiaddr = require('multiaddr');

var OrbitDB = require('orbit-db');

var Pubsub = require('orbit-db-pubsub');

var AccessControllers = require('orbit-db-access-controllers');

var OdbStorage = require('orbit-db-storage-adapter');

var OdbCache = require('orbit-db-cache');

var OdbKeystore = require('orbit-db-keystore');

var _require = require('did-resolver'),
    Resolver = _require.Resolver;

var get3IdResolver = require('3id-resolver').getResolver;

var getMuportResolver = require('muport-did-resolver').getResolver;

var _require2 = require('3box-orbitdb-plugins'),
    OdbIdentityProvider = _require2.OdbIdentityProvider,
    LegacyIPFS3BoxAccessController = _require2.LegacyIPFS3BoxAccessController,
    ThreadAccessController = _require2.ThreadAccessController,
    ModeratorAccessController = _require2.ModeratorAccessController;

AccessControllers.addAccessController({
  AccessController: LegacyIPFS3BoxAccessController
});
AccessControllers.addAccessController({
  AccessController: ThreadAccessController
});
AccessControllers.addAccessController({
  AccessController: ModeratorAccessController
});

var config = require('./config');

var Identities = require('orbit-db-identity-provider');

Identities.addIdentityProvider(OdbIdentityProvider);
var PINNING_NODE = config.pinning_node;
var PINNING_ROOM = config.pinning_room;
var ORBITDB_OPTS = config.orbitdb_options;
var entryTypes = {
  SPACE: 'space',
  ADDRESS_LINK: 'address-link',
  AUTH_DATA: 'auth-data'
};

var Replicator = /*#__PURE__*/function () {
  function Replicator(ipfs, opts) {
    var _this = this;

    (0, _classCallCheck2["default"])(this, Replicator);
    this.events = new EventEmitter();
    this.ipfs = ipfs;
    this._pinningNode = multiaddr(opts.pinningNode || PINNING_NODE);
    this.ipfs.swarm.connect(this._pinningNode);
    this._stores = {};
    this._storePromises = {}; // TODO - this should only be done in 3box-js. For use in
    // 3box-pinning-node the below code should be disabled

    this._hasPubsubMsgs = {};
    var threeIdResolver = get3IdResolver(ipfs, {
      pin: true
    });
    var muportResolver = getMuportResolver(ipfs);
    this.resolver = new Resolver(_objectSpread(_objectSpread({}, threeIdResolver), muportResolver));
    OdbIdentityProvider.setDidResolver(this.resolver);
    this._orbitDbOpts = _objectSpread(_objectSpread({}, ORBITDB_OPTS), {}, {
      format: 'dag-pb',
      accessController: {
        type: 'legacy-ipfs-3box',
        skipManifest: true,
        resolver: this.resolver
      }
    });
    this.events.on('pinning-room-message', function (topic, data) {
      if (data.type === 'HAS_ENTRIES' && data.odbAddress) {
        var odbAddress = data.odbAddress;

        if (_this._pinningRoomFilter) {
          var hasMsgFor = Object.keys(_this._hasPubsubMsgs);

          if (_this._pinningRoomFilter.length <= hasMsgFor.length) {
            var haveAllMsgs = _this._pinningRoomFilter.reduce(function (acc, addr) {
              return acc && hasMsgFor.includes(addr);
            }, true);

            if (haveAllMsgs) {
              _this._pubsub.unsubscribe(PINNING_ROOM);
            }
          } // Before the pinning room filter is created we will keep all has messages
          // in memory. After we only care about the ones that are relevant.


          if (!_this._pinningRoomFilter.includes(odbAddress)) {
            return;
          }
        }

        _this._hasPubsubMsgs[odbAddress] = data;

        _this.events.emit("has-".concat(odbAddress), data);
      }
    });
  }

  (0, _createClass2["default"])(Replicator, [{
    key: "_initPinningRoomFilter",
    value: function _initPinningRoomFilter() {
      this._pinningRoomFilter = this.listStoreAddresses(); // clear out any messages that are not relevant

      for (var odbAddress in this._hasPubsubMsgs) {
        if (!this._pinningRoomFilter.includes(odbAddress)) {
          delete this._hasPubsubMsgs[odbAddress];
        }
      }
    }
  }, {
    key: "_init",
    value: function () {
      var _init2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(opts) {
        var cachePath, levelDown, cacheProxy, cache, keystorePath, keyStorage, keystore, identity;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.t0 = Pubsub;
                _context.t1 = this.ipfs;
                _context.next = 4;
                return this.ipfs.id();

              case 4:
                _context.t2 = _context.sent.id;
                this._pubsub = new _context.t0(_context.t1, _context.t2);
                // Passes default cache but with fixed path instead of path based on
                // orbitdb/ipfs id which can change on page load
                cachePath = path.join(opts.orbitPath || './orbitdb', '/cache');
                levelDown = OdbStorage(null, {});

                if (!opts.cacheProxy) {
                  _context.next = 14;
                  break;
                }

                _context.next = 11;
                return opts.cacheProxy(cachePath);

              case 11:
                _context.t3 = _context.sent;
                _context.next = 17;
                break;

              case 14:
                _context.next = 16;
                return levelDown.createStore(cachePath);

              case 16:
                _context.t3 = _context.sent;

              case 17:
                cacheProxy = _context.t3;
                cache = new OdbCache(cacheProxy);
                keystorePath = path.join(opts.orbitPath || './orbitdb', '/keystore');
                _context.next = 22;
                return levelDown.createStore(keystorePath);

              case 22:
                keyStorage = _context.sent;
                keystore = new OdbKeystore(keyStorage); // Identity not used, passes ref to 3ID orbit identity provider

                _context.next = 26;
                return Identities.createIdentity({
                  id: 'nullid',
                  keystore: keystore
                });

              case 26:
                identity = _context.sent;
                _context.next = 29;
                return OrbitDB.createInstance(this.ipfs, {
                  directory: opts.orbitPath,
                  identity: identity,
                  cache: cache,
                  keystore: keystore
                });

              case 29:
                this._orbitdb = _context.sent;

              case 30:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function _init(_x) {
        return _init2.apply(this, arguments);
      }

      return _init;
    }()
  }, {
    key: "_joinPinningRoom",
    value: function () {
      var _joinPinningRoom2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(firstJoin) {
        var _this2 = this;

        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.t0 = !firstJoin;

                if (!_context2.t0) {
                  _context2.next = 5;
                  break;
                }

                _context2.next = 4;
                return this.ipfs.pubsub.ls();

              case 4:
                _context2.t0 = _context2.sent.includes(PINNING_ROOM);

              case 5:
                if (!_context2.t0) {
                  _context2.next = 7;
                  break;
                }

                return _context2.abrupt("return");

              case 7:
                this._pubsub.subscribe(PINNING_ROOM, function (topic, data) {
                  // console.log('message', topic, data)
                  _this2.events.emit('pinning-room-message', topic, data);
                }, function (topic, peer) {
                  // console.log('peer', topic, peer)
                  _this2.events.emit('pinning-room-peer', topic, peer);
                });

              case 8:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function _joinPinningRoom(_x2) {
        return _joinPinningRoom2.apply(this, arguments);
      }

      return _joinPinningRoom;
    }()
  }, {
    key: "start",
    value: function () {
      var _start = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4(rootstoreAddress, did) {
        var _this3 = this;

        var opts,
            waitForSync,
            _args4 = arguments;
        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                opts = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : {};
                this._did = did;
                _context4.next = 4;
                return this._joinPinningRoom(true);

              case 4:
                this._publishDB({
                  odbAddress: rootstoreAddress
                });

                _context4.next = 7;
                return this._orbitdb.feed(rootstoreAddress, this._orbitDbOpts);

              case 7:
                this.rootstore = _context4.sent;
                _context4.next = 10;
                return this.rootstore.load();

              case 10:
                this.rootstoreSyncDone = this.syncDB(this.rootstore);

                waitForSync = /*#__PURE__*/function () {
                  var _ref = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3() {
                    var addressLinkPinPromise, authDataPinPromise;
                    return _regenerator["default"].wrap(function _callee3$(_context3) {
                      while (1) {
                        switch (_context3.prev = _context3.next) {
                          case 0:
                            _context3.next = 2;
                            return _this3.rootstoreSyncDone;

                          case 2:
                            addressLinkPinPromise = _this3.getAddressLinks();
                            authDataPinPromise = _this3.getAuthData();

                            _this3._initPinningRoomFilter();

                            _context3.next = 7;
                            return _this3._loadStores(opts);

                          case 7:
                            _context3.next = 9;
                            return Promise.all(Object.keys(_this3._stores).map(function (addr) {
                              return _this3.syncDB(_this3._stores[addr]);
                            }));

                          case 9:
                            _context3.next = 11;
                            return addressLinkPinPromise;

                          case 11:
                            _context3.next = 13;
                            return authDataPinPromise;

                          case 13:
                          case "end":
                            return _context3.stop();
                        }
                      }
                    }, _callee3);
                  }));

                  return function waitForSync() {
                    return _ref.apply(this, arguments);
                  };
                }();

                this.syncDone = waitForSync();

              case 13:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function start(_x3, _x4) {
        return _start.apply(this, arguments);
      }

      return start;
    }()
  }, {
    key: "new",
    value: function () {
      var _new2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee5(rootstoreName, pubkey, did) {
        var orbitDbOpts;
        return _regenerator["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (!this.rootstore) {
                  _context5.next = 2;
                  break;
                }

                throw new Error('This method can only be called once before the replicator has started');

              case 2:
                this._did = did;
                _context5.next = 5;
                return this._joinPinningRoom(true);

              case 5:
                orbitDbOpts = merge({}, this._orbitDbOpts, {
                  accessController: {
                    write: [pubkey]
                  }
                });
                _context5.next = 8;
                return this._orbitdb.feed(rootstoreName, orbitDbOpts);

              case 8:
                this.rootstore = _context5.sent;
                this._pinningRoomFilter = [];

                this._publishDB({
                  odbAddress: this.rootstore.address.toString()
                });

                _context5.next = 13;
                return this.rootstore.load();

              case 13:
                this.rootstoreSyncDone = Promise.resolve();
                this.syncDone = Promise.resolve();

              case 15:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function _new(_x5, _x6, _x7) {
        return _new2.apply(this, arguments);
      }

      return _new;
    }()
  }, {
    key: "stop",
    value: function () {
      var _stop = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee6() {
        return _regenerator["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return this._orbitdb.stop();

              case 2:
                _context6.next = 4;
                return this._pubsub.disconnect();

              case 4:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function stop() {
        return _stop.apply(this, arguments);
      }

      return stop;
    }()
  }, {
    key: "addKVStore",
    value: function () {
      var _addKVStore = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee7(name, pubkey, isSpace, did) {
        var storeAddr, orbitDbOpts, store, storeAddress, entries, entry;
        return _regenerator["default"].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (this.rootstore) {
                  _context7.next = 2;
                  break;
                }

                throw new Error('This method can only be called once before the replicator has started');

              case 2:
                storeAddr = Object.keys(this._stores).find(function (addr) {
                  return addr.includes(name);
                });

                if (!storeAddr) {
                  _context7.next = 5;
                  break;
                }

                return _context7.abrupt("return", this._stores[storeAddr]);

              case 5:
                orbitDbOpts = merge({}, this._orbitDbOpts, {
                  accessController: {
                    write: [pubkey]
                  }
                });
                _context7.next = 8;
                return this._orbitdb.keyvalue(name, orbitDbOpts);

              case 8:
                store = _context7.sent;
                storeAddress = store.address.toString();
                this._stores[storeAddress] = store; // add entry to rootstore

                _context7.next = 13;
                return this.rootstoreSyncDone;

              case 13:
                _context7.next = 15;
                return this.rootstore.iterator({
                  limit: -1
                }).collect();

              case 15:
                entries = _context7.sent;
                entry = entries.find(function (entry) {
                  return entry.payload.value.odbAddress === storeAddress;
                });

                if (!isSpace) {
                  _context7.next = 30;
                  break;
                }

                if (entry) {
                  _context7.next = 23;
                  break;
                }

                _context7.next = 21;
                return this.rootstore.add({
                  type: entryTypes.SPACE,
                  DID: did,
                  odbAddress: storeAddress
                });

              case 21:
                _context7.next = 28;
                break;

              case 23:
                if (entry.payload.value.type) {
                  _context7.next = 28;
                  break;
                }

                _context7.next = 26;
                return this.rootstore.del(entry.hash);

              case 26:
                _context7.next = 28;
                return this.rootstore.add({
                  type: entryTypes.SPACE,
                  DID: did,
                  odbAddress: storeAddress
                });

              case 28:
                _context7.next = 33;
                break;

              case 30:
                if (entry) {
                  _context7.next = 33;
                  break;
                }

                _context7.next = 33;
                return this.rootstore.add({
                  odbAddress: storeAddress
                });

              case 33:
                if (!this._hasPubsubMsgs[storeAddress]) {
                  this._hasPubsubMsgs[storeAddress] = {
                    numEntries: 0
                  };
                }

                return _context7.abrupt("return", store);

              case 35:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function addKVStore(_x8, _x9, _x10, _x11) {
        return _addKVStore.apply(this, arguments);
      }

      return addKVStore;
    }()
  }, {
    key: "_loadStores",
    value: function () {
      var _loadStores2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee8(_ref2) {
        var _this4 = this;

        var profile, allSpaces, spacesList, storeEntries, loadPromises;
        return _regenerator["default"].wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                profile = _ref2.profile, allSpaces = _ref2.allSpaces, spacesList = _ref2.spacesList;
                storeEntries = this._listStoreEntries();
                loadPromises = storeEntries.map(function (entry) {
                  var data = entry.payload.value;

                  if (data.type === entryTypes.SPACE && data.DID) {
                    _this4._pinDID(data.DID);
                  }

                  if (profile && (data.odbAddress.includes('public') || data.odbAddress.includes('private'))) {
                    return _this4._loadKeyValueStore(data.odbAddress);
                  } else if (data.odbAddress.includes(entryTypes.SPACE) && (allSpaces || spacesList && spacesList.includes(data.odbAddress.split('.')[2]))) {
                    return _this4._loadKeyValueStore(data.odbAddress);
                  }
                });
                return _context8.abrupt("return", Promise.all(loadPromises));

              case 4:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function _loadStores(_x12) {
        return _loadStores2.apply(this, arguments);
      }

      return _loadStores;
    }()
  }, {
    key: "_loadKeyValueStore",
    value: function () {
      var _loadKeyValueStore2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee9(odbAddress) {
        var _this5 = this;

        return _regenerator["default"].wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                if (!this._storePromises[odbAddress]) {
                  this._storePromises[odbAddress] = new Promise(function (resolve, reject) {
                    _this5._orbitdb.keyvalue(odbAddress, _this5._orbitDbOpts).then(function (store) {
                      store.load().then(function () {
                        resolve(store);
                      });
                    });
                  });
                }

                _context9.next = 3;
                return this._storePromises[odbAddress];

              case 3:
                this._stores[odbAddress] = _context9.sent;
                return _context9.abrupt("return", this._stores[odbAddress]);

              case 5:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function _loadKeyValueStore(_x13) {
        return _loadKeyValueStore2.apply(this, arguments);
      }

      return _loadKeyValueStore;
    }()
  }, {
    key: "getStore",
    value: function () {
      var _getStore = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee10(odbAddress) {
        return _regenerator["default"].wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                return _context10.abrupt("return", this._stores[odbAddress] || this._loadKeyValueStore(odbAddress));

              case 1:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function getStore(_x14) {
        return _getStore.apply(this, arguments);
      }

      return getStore;
    }()
  }, {
    key: "listStoreAddresses",
    value: function listStoreAddresses() {
      return this._listStoreEntries().map(function (entry) {
        return entry.payload.value.odbAddress;
      });
    }
  }, {
    key: "_listStoreEntries",
    value: function _listStoreEntries() {
      var entries = this.rootstore.iterator({
        limit: -1
      }).collect().filter(function (e) {
        return OrbitDB.isValidAddress(e.payload.value.odbAddress || '');
      });
      var uniqueEntries = entries.filter(function (e1, i, a) {
        return a.findIndex(function (e2) {
          return e2.payload.value.odbAddress === e1.payload.value.odbAddress;
        }) === i;
      });
      return uniqueEntries;
    }
  }, {
    key: "getAddressLinks",
    value: function () {
      var _getAddressLinks = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee11() {
        var entries, linkEntries, resolveLinks, _iterator, _step, entry, cid, dag;

        return _regenerator["default"].wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                _context11.next = 2;
                return this.rootstore.iterator({
                  limit: -1
                }).collect();

              case 2:
                entries = _context11.sent;
                linkEntries = entries.filter(function (e) {
                  return e.payload.value.type === entryTypes.ADDRESS_LINK;
                });
                resolveLinks = [];
                _iterator = _createForOfIteratorHelper(linkEntries);
                _context11.prev = 6;

                _iterator.s();

              case 8:
                if ((_step = _iterator.n()).done) {
                  _context11.next = 23;
                  break;
                }

                entry = _step.value;
                cid = entry.payload.value.data;
                _context11.prev = 11;
                _context11.next = 14;
                return pTimeout(this.ipfs.dag.get(cid), 2500);

              case 14:
                dag = _context11.sent;
                resolveLinks.push(Object.assign(dag.value, {
                  entry: entry
                }));
                this.ipfs.pin.add(cid);
                _context11.next = 21;
                break;

              case 19:
                _context11.prev = 19;
                _context11.t0 = _context11["catch"](11);

              case 21:
                _context11.next = 8;
                break;

              case 23:
                _context11.next = 28;
                break;

              case 25:
                _context11.prev = 25;
                _context11.t1 = _context11["catch"](6);

                _iterator.e(_context11.t1);

              case 28:
                _context11.prev = 28;

                _iterator.f();

                return _context11.finish(28);

              case 31:
                return _context11.abrupt("return", resolveLinks);

              case 32:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this, [[6, 25, 28, 31], [11, 19]]);
      }));

      function getAddressLinks() {
        return _getAddressLinks.apply(this, arguments);
      }

      return getAddressLinks;
    }()
  }, {
    key: "getAuthData",
    value: function () {
      var _getAuthData = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee13() {
        var _this6 = this;

        var entries, authEntries, resolveLinks;
        return _regenerator["default"].wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                _context13.next = 2;
                return this.rootstore.iterator({
                  limit: -1
                }).collect();

              case 2:
                entries = _context13.sent;
                authEntries = entries.filter(function (e) {
                  return e.payload.value.type === entryTypes.AUTH_DATA;
                });
                resolveLinks = authEntries.map( /*#__PURE__*/function () {
                  var _ref3 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee12(entry) {
                    var cid, obj;
                    return _regenerator["default"].wrap(function _callee12$(_context12) {
                      while (1) {
                        switch (_context12.prev = _context12.next) {
                          case 0:
                            cid = entry.payload.value.data; // TODO handle missing ipfs obj??, timeouts?

                            _context12.next = 3;
                            return _this6.ipfs.dag.get(cid);

                          case 3:
                            obj = _context12.sent.value;

                            _this6.ipfs.pin.add(cid);

                            obj.entry = entry;
                            return _context12.abrupt("return", obj);

                          case 7:
                          case "end":
                            return _context12.stop();
                        }
                      }
                    }, _callee12);
                  }));

                  return function (_x15) {
                    return _ref3.apply(this, arguments);
                  };
                }());
                return _context13.abrupt("return", Promise.all(resolveLinks));

              case 6:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function getAuthData() {
        return _getAuthData.apply(this, arguments);
      }

      return getAuthData;
    }()
  }, {
    key: "ensureConnected",
    value: function () {
      var _ensureConnected = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee14(odbAddress) {
        var _this7 = this;

        var isThread, roomPeers;
        return _regenerator["default"].wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                isThread = odbAddress.includes('thread');
                _context14.next = 3;
                return this.ipfs.pubsub.peers(odbAddress);

              case 3:
                roomPeers = _context14.sent;

                if (!roomPeers.find(function (p) {
                  return p === _this7._pinningNodePeerId;
                })) {
                  this.ipfs.swarm.connect(this._pinningNode);
                  odbAddress = isThread ? odbAddress : this.rootstore.address.toString();

                  this._publishDB({
                    odbAddress: odbAddress,
                    isThread: isThread
                  }, true);
                }

              case 5:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function ensureConnected(_x16) {
        return _ensureConnected.apply(this, arguments);
      }

      return ensureConnected;
    }()
  }, {
    key: "_publishDB",
    value: function () {
      var _publishDB2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee15(_ref4, unsubscribe) {
        var _this8 = this;

        var odbAddress, isThread, pinningNodeJoined;
        return _regenerator["default"].wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                odbAddress = _ref4.odbAddress, isThread = _ref4.isThread;

                this._joinPinningRoom();

                odbAddress = odbAddress || this.rootstore.address.toString(); // make sure that the pinning node is in the pubsub room before publishing

                pinningNodeJoined = new Promise(function (resolve, reject) {
                  _this8.events.on('pinning-room-peer', function (topic, peer) {
                    if (peer === _this8._pinningNodePeerId) {
                      resolve();
                    }
                  });
                });
                _context15.next = 6;
                return this.ipfs.pubsub.peers(PINNING_ROOM);

              case 6:
                if (_context15.sent.includes(this._pinningNodePeerId)) {
                  _context15.next = 9;
                  break;
                }

                _context15.next = 9;
                return pinningNodeJoined;

              case 9:
                this._pubsub.publish(PINNING_ROOM, {
                  type: isThread ? 'SYNC_DB' : 'PIN_DB',
                  odbAddress: odbAddress,
                  did: this._did,
                  thread: isThread
                });

                this.events.removeAllListeners('pinning-room-peer');

                if (unsubscribe) {
                  this._pubsub.unsubscribe(PINNING_ROOM);
                }

              case 12:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function _publishDB(_x17, _x18) {
        return _publishDB2.apply(this, arguments);
      }

      return _publishDB;
    }()
  }, {
    key: "_getNumEntries",
    value: function () {
      var _getNumEntries2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee16(odbAddress) {
        var _this9 = this;

        return _regenerator["default"].wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                return _context16.abrupt("return", new Promise(function (resolve, reject) {
                  var eventName = "has-".concat(odbAddress);

                  _this9.events.on(eventName, function (data) {
                    _this9.events.removeAllListeners(eventName);

                    resolve(data.numEntries);
                  });

                  if (_this9._hasPubsubMsgs[odbAddress]) {
                    _this9.events.removeAllListeners(eventName);

                    resolve(_this9._hasPubsubMsgs[odbAddress].numEntries);
                  }
                }));

              case 1:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16);
      }));

      function _getNumEntries(_x19) {
        return _getNumEntries2.apply(this, arguments);
      }

      return _getNumEntries;
    }()
  }, {
    key: "syncDB",
    value: function () {
      var _syncDB = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee17(dbInstance) {
        var numRemoteEntries, isNumber;
        return _regenerator["default"].wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                _context17.next = 2;
                return this._getNumEntries(dbInstance.address.toString());

              case 2:
                numRemoteEntries = _context17.sent;
                isNumber = typeof numRemoteEntries === 'number';

                if (!(isNumber && numRemoteEntries <= dbInstance._oplog.values.length)) {
                  _context17.next = 6;
                  break;
                }

                return _context17.abrupt("return", Promise.resolve());

              case 6:
                _context17.next = 8;
                return new Promise(function (resolve, reject) {
                  dbInstance.events.on('replicated', function () {
                    if (numRemoteEntries <= dbInstance._oplog.values.length) {
                      resolve();
                      dbInstance.events.removeAllListeners('replicated');
                    }
                  });
                });

              case 8:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function syncDB(_x20) {
        return _syncDB.apply(this, arguments);
      }

      return syncDB;
    }()
  }, {
    key: "_pinDID",
    value: function () {
      var _pinDID2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee18(did) {
        return _regenerator["default"].wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                if (did) {
                  _context18.next = 2;
                  break;
                }

                return _context18.abrupt("return");

              case 2:
                _context18.prev = 2;
                _context18.next = 5;
                return this.resolver.resolve(did);

              case 5:
                _context18.next = 9;
                break;

              case 7:
                _context18.prev = 7;
                _context18.t0 = _context18["catch"](2);

              case 9:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this, [[2, 7]]);
      }));

      function _pinDID(_x21) {
        return _pinDID2.apply(this, arguments);
      }

      return _pinDID;
    }()
  }, {
    key: "_pinningNodePeerId",
    get: function get() {
      return this._pinningNode.getPeerId();
    }
  }], [{
    key: "create",
    value: function () {
      var _create = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee19(ipfs) {
        var opts,
            replicator,
            _args19 = arguments;
        return _regenerator["default"].wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                opts = _args19.length > 1 && _args19[1] !== undefined ? _args19[1] : {};
                replicator = new Replicator(ipfs, opts);
                _context19.next = 4;
                return replicator._init(opts);

              case 4:
                return _context19.abrupt("return", replicator);

              case 5:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19);
      }));

      function create(_x22) {
        return _create.apply(this, arguments);
      }

      return create;
    }()
  }, {
    key: "entryTypes",
    get: function get() {
      return entryTypes;
    }
  }]);
  return Replicator;
}();

module.exports = Replicator;