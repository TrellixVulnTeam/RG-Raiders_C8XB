"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var graphQLRequest = require('graphql-request').request;

var utils = require('./utils/index');

var verifier = require('./utils/verifier');

var _require = require('./utils/id'),
    isSupportedDID = _require.isSupportedDID;

var config = require('./config.js');

var GRAPHQL_SERVER_URL = config.graphql_server_url;
var PROFILE_SERVER_URL = config.profile_server_url;
var ADDRESS_SERVER_URL = config.address_server_url;
/**
 * @class
 */

var BoxApi = /*#__PURE__*/function () {
  function BoxApi() {
    (0, _classCallCheck2["default"])(this, BoxApi);
  }

  (0, _createClass2["default"])(BoxApi, null, [{
    key: "getRootStoreAddress",
    value: function () {
      var _getRootStoreAddress = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(identifier) {
        var serverUrl,
            res,
            _args = arguments;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                serverUrl = _args.length > 1 && _args[1] !== undefined ? _args[1] : ADDRESS_SERVER_URL;
                _context.next = 3;
                return utils.fetchJson(serverUrl + '/odbAddress/' + identifier);

              case 3:
                res = _context.sent;
                return _context.abrupt("return", res.data.rootStoreAddress);

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function getRootStoreAddress(_x) {
        return _getRootStoreAddress.apply(this, arguments);
      }

      return getRootStoreAddress;
    }()
    /**
     * Get the names of all spaces a user has
     *
     * @param     {String}    address                 An ethereum address
     * @param     {Object}    opts                    Optional parameters
     * @param     {String}    opts.profileServer      URL of Profile API server
     * @return    {Object}                            an array with all spaces as strings
     */

  }, {
    key: "listSpaces",
    value: function () {
      var _listSpaces = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(address) {
        var _ref,
            profileServer,
            serverUrl,
            _args2 = arguments;

        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _ref = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {}, profileServer = _ref.profileServer;
                serverUrl = profileServer || PROFILE_SERVER_URL;
                _context2.prev = 2;

                if (!isSupportedDID(address)) {
                  _context2.next = 9;
                  break;
                }

                _context2.next = 6;
                return utils.fetchJson(serverUrl + '/list-spaces?did=' + address);

              case 6:
                return _context2.abrupt("return", _context2.sent);

              case 9:
                _context2.next = 11;
                return utils.fetchJson(serverUrl + '/list-spaces?address=' + encodeURIComponent(address));

              case 11:
                return _context2.abrupt("return", _context2.sent);

              case 12:
                _context2.next = 17;
                break;

              case 14:
                _context2.prev = 14;
                _context2.t0 = _context2["catch"](2);
                return _context2.abrupt("return", []);

              case 17:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, null, [[2, 14]]);
      }));

      function listSpaces(_x2) {
        return _listSpaces.apply(this, arguments);
      }

      return listSpaces;
    }()
    /**
     * Get the public data in a space of a given address with the given name
     *
     * @param     {String}    address                 An ethereum address
     * @param     {String}    name                    A space name
     * @param     {Object}    opts                    Optional parameters
     * @param     {Function}  opts.blocklist          A function that takes an address and returns true if the user has been blocked
     * @param     {String}    opts.metadata           flag to retrieve metadata
     * @param     {String}    opts.profileServer      URL of Profile API server
     * @return    {Object}                            a json object with the public space data
     */

  }, {
    key: "getSpace",
    value: function () {
      var _getSpace = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(address, name) {
        var _ref2,
            profileServer,
            metadata,
            blocklist,
            serverUrl,
            url,
            _args3 = arguments;

        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _ref2 = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : {}, profileServer = _ref2.profileServer, metadata = _ref2.metadata, blocklist = _ref2.blocklist;

                if (!(blocklist && blocklist(address))) {
                  _context3.next = 3;
                  break;
                }

                throw new Error("user with ".concat(address, " is blocked"));

              case 3:
                serverUrl = profileServer || PROFILE_SERVER_URL;
                url = "".concat(serverUrl, "/space");
                _context3.prev = 5;

                // Add first parameter: address or did
                if (isSupportedDID(address)) {
                  url = "".concat(url, "?did=").concat(address);
                } else {
                  url = "".concat(url, "?address=").concat(encodeURIComponent(address.toLowerCase()));
                } // Add name:


                url = "".concat(url, "&name=").concat(encodeURIComponent(name)); // Add metadata:

                if (metadata) {
                  url = "".concat(url, "&metadata=").concat(encodeURIComponent(metadata));
                } // Query:
                // we await explicitly to make sure the error is catch'd in the correct scope


                _context3.next = 11;
                return utils.fetchJson(url);

              case 11:
                return _context3.abrupt("return", _context3.sent);

              case 14:
                _context3.prev = 14;
                _context3.t0 = _context3["catch"](5);
                return _context3.abrupt("return", {});

              case 17:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, null, [[5, 14]]);
      }));

      function getSpace(_x3, _x4) {
        return _getSpace.apply(this, arguments);
      }

      return getSpace;
    }() // TODO consumes address now, could also give root DID to get space DID

  }, {
    key: "getSpaceDID",
    value: function () {
      var _getSpaceDID = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4(address, space) {
        var opts,
            conf,
            _args4 = arguments;
        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                opts = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : {};
                _context4.next = 3;
                return BoxApi.getConfig(address, opts);

              case 3:
                conf = _context4.sent;

                if (!(!conf.spaces[space] || !conf.spaces[space].DID)) {
                  _context4.next = 6;
                  break;
                }

                throw new Error("Could not find appropriate DID for address ".concat(address));

              case 6:
                return _context4.abrupt("return", conf.spaces[space].DID);

              case 7:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      }));

      function getSpaceDID(_x5, _x6) {
        return _getSpaceDID.apply(this, arguments);
      }

      return getSpaceDID;
    }()
    /**
     * Get all posts that are made to a thread.
     *
     * @param     {String}    space                   The name of the space the thread is in
     * @param     {String}    name                    The name of the thread
     * @param     {String}    firstModerator          The DID (or ethereum address) of the first moderator
     * @param     {Boolean}   members                 True if only members are allowed to post
     * @param     {Object}    opts                    Optional parameters
     * @param     {String}    opts.profileServer      URL of Profile API server
     * @return    {Array<Object>}                     An array of posts
     */

  }, {
    key: "getThread",
    value: function () {
      var _getThread = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee5(space, name, firstModerator, members) {
        var opts,
            serverUrl,
            url,
            _args5 = arguments;
        return _regenerator["default"].wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                opts = _args5.length > 4 && _args5[4] !== undefined ? _args5[4] : {};
                serverUrl = opts.profileServer || PROFILE_SERVER_URL;

                if (!firstModerator.startsWith('0x')) {
                  _context5.next = 6;
                  break;
                }

                _context5.next = 5;
                return BoxApi.getSpaceDID(firstModerator, space, opts);

              case 5:
                firstModerator = _context5.sent;

              case 6:
                _context5.prev = 6;
                url = "".concat(serverUrl, "/thread?space=").concat(encodeURIComponent(space), "&name=").concat(encodeURIComponent(name));
                url += "&mod=".concat(encodeURIComponent(firstModerator), "&members=").concat(encodeURIComponent(members));
                _context5.next = 11;
                return utils.fetchJson(url);

              case 11:
                return _context5.abrupt("return", _context5.sent);

              case 14:
                _context5.prev = 14;
                _context5.t0 = _context5["catch"](6);
                throw new Error(_context5.t0);

              case 17:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, null, [[6, 14]]);
      }));

      function getThread(_x7, _x8, _x9, _x10) {
        return _getThread.apply(this, arguments);
      }

      return getThread;
    }()
    /**
     * Get all posts that are made to a thread.
     *
     * @param     {String}    address                 The orbitdb-address of the thread
     * @param     {Object}    opts                    Optional parameters
     * @param     {String}    opts.profileServer      URL of Profile API server
     * @return    {Array<Object>}                     An array of posts
     */

  }, {
    key: "getThreadByAddress",
    value: function () {
      var _getThreadByAddress = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee6(address) {
        var opts,
            serverUrl,
            _args6 = arguments;
        return _regenerator["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                opts = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : {};
                serverUrl = opts.profileServer || PROFILE_SERVER_URL;
                _context6.prev = 2;
                _context6.next = 5;
                return utils.fetchJson("".concat(serverUrl, "/thread?address=").concat(encodeURIComponent(address)));

              case 5:
                return _context6.abrupt("return", _context6.sent);

              case 8:
                _context6.prev = 8;
                _context6.t0 = _context6["catch"](2);
                throw new Error(_context6.t0);

              case 11:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, null, [[2, 8]]);
      }));

      function getThreadByAddress(_x11) {
        return _getThreadByAddress.apply(this, arguments);
      }

      return getThreadByAddress;
    }()
    /**
     * Get the configuration of a users 3Box
     *
     * @param     {String}    address                 The ethereum address
     * @param     {Object}    opts                    Optional parameters
     * @param     {String}    opts.profileServer      URL of Profile API server
     * @return    {Array<Object>}                     An array of posts
     */

  }, {
    key: "getConfig",
    value: function () {
      var _getConfig = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee7(address) {
        var opts,
            serverUrl,
            isAddr,
            _args7 = arguments;
        return _regenerator["default"].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                opts = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : {};
                serverUrl = opts.profileServer || PROFILE_SERVER_URL;
                isAddr = address.startsWith('0x'); // assume 3ID if not address

                _context7.prev = 3;
                _context7.next = 6;
                return utils.fetchJson("".concat(serverUrl, "/config?").concat(isAddr ? 'address' : 'did', "=").concat(encodeURIComponent(address)));

              case 6:
                return _context7.abrupt("return", _context7.sent);

              case 9:
                _context7.prev = 9;
                _context7.t0 = _context7["catch"](3);
                throw new Error(_context7.t0);

              case 12:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, null, [[3, 9]]);
      }));

      function getConfig(_x12) {
        return _getConfig.apply(this, arguments);
      }

      return getConfig;
    }()
    /**
     * Get the public profile of a given address
     *
     * @param     {String}    address                 An ethereum address
     * @param     {Object}    opts                    Optional parameters
     * @param     {Function}  opts.blocklist          A function that takes an address and returns true if the user has been blocked
     * @param     {String}    opts.metadata           flag to retrieve metadata
     * @param     {String}    opts.profileServer      URL of Profile API server
     * @return    {Object}                            a json object with the profile for the given address
     */

  }, {
    key: "getProfile",
    value: function () {
      var _getProfile = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee8(address) {
        var _ref3,
            profileServer,
            metadata,
            blocklist,
            serverUrl,
            url,
            _args8 = arguments;

        return _regenerator["default"].wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _ref3 = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : {}, profileServer = _ref3.profileServer, metadata = _ref3.metadata, blocklist = _ref3.blocklist;

                if (!(blocklist && blocklist(address))) {
                  _context8.next = 3;
                  break;
                }

                throw new Error("user with ".concat(address, " is blocked"));

              case 3:
                serverUrl = profileServer || PROFILE_SERVER_URL;
                url = "".concat(serverUrl, "/profile");
                _context8.prev = 5;

                // Add first parameter: address or did
                if (isSupportedDID(address)) {
                  url = "".concat(url, "?did=").concat(address);
                } else {
                  url = "".concat(url, "?address=").concat(encodeURIComponent(address.toLowerCase()));
                } // Add metadata:


                if (metadata) {
                  url = "".concat(url, "&metadata=").concat(encodeURIComponent(metadata));
                } // Query:
                // we await explicitly to make sure the error is catch'd in the correct scope


                _context8.next = 10;
                return utils.fetchJson(url);

              case 10:
                return _context8.abrupt("return", _context8.sent);

              case 13:
                _context8.prev = 13;
                _context8.t0 = _context8["catch"](5);
                return _context8.abrupt("return", {});

              case 16:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, null, [[5, 13]]);
      }));

      function getProfile(_x13) {
        return _getProfile.apply(this, arguments);
      }

      return getProfile;
    }()
    /**
     * Get a list of public profiles for given addresses. This relies on 3Box profile API.
     *
     * @param     {Array}     address                 An array of ethereum addresses
     * @param     {Object}    opts                    Optional parameters
     * @param     {String}    opts.profileServer      URL of Profile API server
     * @return    {Object}                            a json object with each key an address and value the profile
     */

  }, {
    key: "getProfiles",
    value: function () {
      var _getProfiles = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee9(addressArray) {
        var opts,
            req,
            url,
            _args9 = arguments;
        return _regenerator["default"].wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                opts = _args9.length > 1 && _args9[1] !== undefined ? _args9[1] : {};
                opts = Object.assign({
                  profileServer: PROFILE_SERVER_URL
                }, opts);
                req = {
                  addressList: [],
                  didList: []
                }; // Split addresses on ethereum / dids

                addressArray.forEach(function (address) {
                  if (isSupportedDID(address)) {
                    req.didList.push(address);
                  } else {
                    req.addressList.push(address);
                  }
                });
                url = "".concat(opts.profileServer, "/profileList");
                return _context9.abrupt("return", utils.fetchJson(url, req));

              case 6:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9);
      }));

      function getProfiles(_x14) {
        return _getProfiles.apply(this, arguments);
      }

      return getProfiles;
    }()
    /**
     * GraphQL for 3Box profile API
     *
     * @param     {Object}    query               A graphQL query object.
     * @param     {Object}    opts                Optional parameters
     * @param     {String}    opts.graphqlServer  URL of graphQL 3Box profile service
     * @return    {Object}                        a json object with each key an address and value the profile
     */

  }, {
    key: "profileGraphQL",
    value: function () {
      var _profileGraphQL = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee10(query) {
        var opts,
            _args10 = arguments;
        return _regenerator["default"].wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                opts = _args10.length > 1 && _args10[1] !== undefined ? _args10[1] : {};
                opts = Object.assign({
                  graphqlServer: GRAPHQL_SERVER_URL
                }, opts);
                return _context10.abrupt("return", graphQLRequest(opts.graphqlServer, query));

              case 3:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10);
      }));

      function profileGraphQL(_x15) {
        return _profileGraphQL.apply(this, arguments);
      }

      return profileGraphQL;
    }()
    /**
     * Verifies the proofs of social accounts that is present in the profile.
     *
     * @param     {Object}            profile                 A user profile object, received from the `getProfile` function
     * @return    {Object}                                    An object containing the accounts that have been verified
     */

  }, {
    key: "getVerifiedAccounts",
    value: function () {
      var _getVerifiedAccounts = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee11(profile) {
        var verifs, didVerified, dids;
        return _regenerator["default"].wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                verifs = {};
                _context11.prev = 1;
                _context11.next = 4;
                return verifier.verifyDID(profile.proof_did);

              case 4:
                didVerified = _context11.sent;
                dids = [didVerified.did];
                verifs.did = didVerified.did;

                if (didVerified.muport) {
                  verifs.muport = didVerified.muport;
                  dids.push(didVerified.muport);
                }

                if (!profile.proof_github) {
                  _context11.next = 17;
                  break;
                }

                _context11.prev = 9;
                _context11.next = 12;
                return verifier.verifyGithub(dids, profile.proof_github);

              case 12:
                verifs.github = _context11.sent;
                _context11.next = 17;
                break;

              case 15:
                _context11.prev = 15;
                _context11.t0 = _context11["catch"](9);

              case 17:
                if (!profile.proof_twitter) {
                  _context11.next = 26;
                  break;
                }

                _context11.prev = 18;
                _context11.next = 21;
                return verifier.verifyTwitter(dids, profile.proof_twitter);

              case 21:
                verifs.twitter = _context11.sent;
                _context11.next = 26;
                break;

              case 24:
                _context11.prev = 24;
                _context11.t1 = _context11["catch"](18);

              case 26:
                if (!profile.ethereum_proof) {
                  _context11.next = 35;
                  break;
                }

                _context11.prev = 27;
                _context11.next = 30;
                return verifier.verifyEthereum(profile.ethereum_proof, verifs.did);

              case 30:
                verifs.ethereum = _context11.sent;
                _context11.next = 35;
                break;

              case 33:
                _context11.prev = 33;
                _context11.t2 = _context11["catch"](27);

              case 35:
                _context11.next = 39;
                break;

              case 37:
                _context11.prev = 37;
                _context11.t3 = _context11["catch"](1);

              case 39:
                return _context11.abrupt("return", verifs);

              case 40:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, null, [[1, 37], [9, 15], [18, 24], [27, 33]]);
      }));

      function getVerifiedAccounts(_x16) {
        return _getVerifiedAccounts.apply(this, arguments);
      }

      return getVerifiedAccounts;
    }()
  }]);
  return BoxApi;
}();

module.exports = BoxApi;