"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

var IPFS = require('ipfs');

var multiaddr = require('multiaddr');

var _require = require('3id-blockchain-utils'),
    createLink = _require.createLink,
    validateLink = _require.validateLink;

var ThreeId = require('./3id');

var Replicator = require('./replicator');

var PublicStore = require('./publicStore');

var PrivateStore = require('./privateStore');

var Verified = require('./verified');

var Space = require('./space');

var utils = require('./utils/index');

var idUtils = require('./utils/id');

var config = require('./config');

var BoxApi = require('./api');

var IPFSRepo = require('ipfs-repo');

var LevelStore = require('datastore-level');

var didJWT = require('did-jwt');

var _require2 = require('3id-connect'),
    ThreeIdConnect = _require2.ThreeIdConnect;

var _require3 = require('3box-shared-cache'),
    IframeCache = _require3.IframeCache;

var PINNING_NODE = config.pinning_node;
var ADDRESS_SERVER_URL = config.address_server_url;
var IPFS_OPTIONS = config.ipfs_options;
var RENDEZVOUS_ADDRESS = config.rendezvous_address;
var THREEID_CONNECT_URL = config.threeid_connect_url;
var IFRAME_CACHE_URL = config.iframe_cache_url;
var supportAlert = 'This site uses local data storage to give you control of your data. Please enable web APIs like localstorage, indexxeddb, etc in your browser settings.';
var globalIPFS, globalIPFSPromise, threeIdConnect, iframeCacheService, cacheSupportedPromise;
var browserHuh = typeof window !== 'undefined' && typeof document !== 'undefined';

if (browserHuh) {
  require('./modernizr.js');

  threeIdConnect = new ThreeIdConnect(THREEID_CONNECT_URL);
  iframeCacheService = new IframeCache(IFRAME_CACHE_URL);
  cacheSupportedPromise = iframeCacheService.connect();
}
/**
 * @extends BoxApi
 */


var Box = /*#__PURE__*/function (_BoxApi) {
  (0, _inherits2["default"])(Box, _BoxApi);

  var _super = _createSuper(Box);

  /**
   * Please use the **openBox** method to instantiate a 3Box
   * @constructor
   */
  function Box(provider, ipfs) {
    var _this;

    var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    (0, _classCallCheck2["default"])(this, Box);
    _this = _super.call(this);
    _this._provider = provider;
    _this._ipfs = ipfs;
    _this._opts = opts;
    _this._serverUrl = opts.addressServer || ADDRESS_SERVER_URL;
    /**
     * @property {KeyValueStore} public         access the profile store of the users 3Box
     */

    _this["public"] = null;
    /**
     * @property {KeyValueStore} private        access the private store of the users 3Box
     */

    _this["private"] = null;
    /**
     * @property {Verified} verified        check and create verifications
     */

    _this.verified = new Verified((0, _assertThisInitialized2["default"])(_this));
    /**
     * @property {Object} spaces            an object containing all open spaces indexed by their name.
     */

    _this.spaces = {};
    /**
     * @property {Promise} syncDone         A promise that is resolved when the box is synced
     */

    _this.syncDone = null;
    _this.hasPublishedLink = {};
    return _this;
  }

  (0, _createClass2["default"])(Box, [{
    key: "_init",
    value: function () {
      var _init2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(opts) {
        var replicatorOpts, cacheSupported, self, peerId;
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                replicatorOpts = _objectSpread({}, opts);

                if (!(opts.iframeCache && iframeCacheService)) {
                  _context2.next = 6;
                  break;
                }

                _context2.next = 4;
                return cacheSupportedPromise;

              case 4:
                cacheSupported = _context2.sent;

                if (cacheSupported) {
                  replicatorOpts.cacheProxy = iframeCacheService.getOrbitStorageProxyFactory();
                }

              case 6:
                _context2.next = 8;
                return Replicator.create(this._ipfs, replicatorOpts);

              case 8:
                this.replicator = _context2.sent;

                if (opts.ghostPinbot) {
                  this._ghostPinbot = opts.ghostPinbot;
                  self = this;
                  peerId = utils.getPeerIdFromMultiaddr(opts.ghostPinbot); // ping Ghost Pinbot to keep connection alive

                  this.ghostPinbotKeepAliveHandle = setInterval( /*#__PURE__*/(0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
                    return _regenerator["default"].wrap(function _callee$(_context) {
                      while (1) {
                        switch (_context.prev = _context.next) {
                          case 0:
                            _context.next = 2;
                            return self._ipfs.ping(peerId);

                          case 2:
                          case "end":
                            return _context.stop();
                        }
                      }
                    }, _callee);
                  })), 10000);
                }

              case 10:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function _init(_x) {
        return _init2.apply(this, arguments);
      }

      return _init;
    }()
  }, {
    key: "_load",
    value: function () {
      var _load2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3() {
        var _this2 = this;

        var opts,
            address,
            _ref2,
            rootStoreAddress,
            did,
            authData,
            rootstoreName,
            key,
            _args3 = arguments;

        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                opts = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : {};
                _context3.t0 = opts.address;

                if (_context3.t0) {
                  _context3.next = 6;
                  break;
                }

                _context3.next = 5;
                return this._3id.getAddress();

              case 5:
                _context3.t0 = _context3.sent;

              case 6:
                address = _context3.t0;

                if (!address) {
                  _context3.next = 13;
                  break;
                }

                _context3.next = 10;
                return this._getLinkedData(address);

              case 10:
                _context3.t1 = _context3.sent;
                _context3.next = 14;
                break;

              case 13:
                _context3.t1 = {};

              case 14:
                _ref2 = _context3.t1;
                rootStoreAddress = _ref2.rootStoreAddress;
                did = _ref2.did;

                if (!(rootStoreAddress && !rootStoreAddress.includes(','))) {
                  _context3.next = 29;
                  break;
                }

                _context3.next = 20;
                return this.replicator.start(rootStoreAddress, did, {
                  profile: true
                });

              case 20:
                _context3.next = 22;
                return this.replicator.rootstoreSyncDone;

              case 22:
                _context3.next = 24;
                return this.replicator.getAuthData();

              case 24:
                authData = _context3.sent;
                _context3.next = 27;
                return this._3id.authenticate(opts.spaces, {
                  authData: authData,
                  address: address
                });

              case 27:
                _context3.next = 38;
                break;

              case 29:
                _context3.next = 31;
                return this._3id.authenticate(opts.spaces, {
                  address: address
                });

              case 31:
                rootstoreName = this._3id.muportFingerprint + '.root';
                _context3.next = 34;
                return this._3id.getPublicKeys(null, true);

              case 34:
                key = _context3.sent.signingKey;
                _context3.next = 37;
                return this.replicator["new"](rootstoreName, key, this._3id.DID);

              case 37:
                this._publishRootStore(this.replicator.rootstore.address.toString());

              case 38:
                _context3.t2 = this.replicator.rootstore;
                _context3.next = 41;
                return this._3id.getOdbId();

              case 41:
                _context3.t3 = _context3.sent;

                _context3.t2.setIdentity.call(_context3.t2, _context3.t3);

                this.syncDone = this.replicator.syncDone;

                this._3id.events.on('new-auth-method', function (authData) {
                  _this2._writeRootstoreEntry(Replicator.entryTypes.AUTH_DATA, authData);
                });

                this._3id.events.on('new-link-proof', function (proof) {
                  _this2._writeAddressLink(proof);
                });

                this._3id.startUpdatePolling();

                this["public"] = new PublicStore(this._3id.muportFingerprint + '.public', this.replicator, this._3id);
                this["private"] = new PrivateStore(this._3id.muportFingerprint + '.private', this.replicator, this._3id);
                _context3.next = 51;
                return this["public"]._load();

              case 51:
                _context3.next = 53;
                return this["private"]._load();

              case 53:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function _load() {
        return _load2.apply(this, arguments);
      }

      return _load;
    }()
    /**
     * Creates an instance of 3Box
     *
     * @param     {provider}          provider                A 3ID provider, or ethereum provider
     * @param     {Object}            opts                    Optional parameters
     * @param     {String}            opts.pinningNode        A string with an ipfs multi-address to a 3box pinning node
     * @param     {Object}            opts.ipfs               A js-ipfs ipfs object
     * @param     {String}            opts.addressServer      URL of the Address Server
     * @param     {String}            opts.ghostPinbot        MultiAddress of a Ghost Pinbot node
     * @param     {String}            opts.supportCheck       Gives browser alert if 3boxjs/ipfs not supported in browser env, defaults to true. You can also set to false to implement your own alert and call Box.support to check if supported.
     * @param     {Boolean}           opts.iframeCache        Enable iframe cache for ipfs/orbit, defaults to true
     * @return    {Box}                                       the 3Box session instance
     */

  }, {
    key: "_setProvider",
    value: function () {
      var _setProvider2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4(provider) {
        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (provider) {
                  _context4.next = 2;
                  break;
                }

                return _context4.abrupt("return");

              case 2:
                if (!(!provider.is3idProvider && threeIdConnect)) {
                  _context4.next = 10;
                  break;
                }

                _context4.next = 5;
                return threeIdConnect.connect(provider, ThreeId, this._ipfs);

              case 5:
                _context4.next = 7;
                return threeIdConnect.get3idProvider();

              case 7:
                this._provider = _context4.sent;
                _context4.next = 11;
                break;

              case 10:
                this._provider = provider;

              case 11:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function _setProvider(_x2) {
        return _setProvider2.apply(this, arguments);
      }

      return _setProvider;
    }()
    /**
     * Authenticate the user
     *
     * @param     {Array<String>}     spaces                  A list of spaces to authenticate (optional)
     * @param     {Object}            opts                    Optional parameters
     * @param     {String}            opts.address            An ethereum address
     * @param     {String}            opts.provider           A 3ID provider, or ethereum provider
     * @param     {Function}          opts.consentCallback    A function that will be called when the user has consented to opening the box
     */

  }, {
    key: "auth",
    value: function () {
      var _auth = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee6() {
        var _this3 = this;

        var spaces,
            opts,
            _args6 = arguments;
        return _regenerator["default"].wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                spaces = _args6.length > 0 && _args6[0] !== undefined ? _args6[0] : [];
                opts = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : {};

                if (!opts.provider) {
                  _context6.next = 5;
                  break;
                }

                _context6.next = 5;
                return this._setProvider(opts.provider);

              case 5:
                if (this._provider) {
                  _context6.next = 7;
                  break;
                }

                throw new Error('auth: provider was not passed to auth or create, provider required');

              case 7:
                opts.address = opts.address ? opts.address.toLowerCase() : opts.address;
                this._3idEthAddress = opts.address;

                if (this._3id) {
                  _context6.next = 19;
                  break;
                }

                if (!(!this._provider.is3idProvider && !opts.address)) {
                  _context6.next = 12;
                  break;
                }

                throw new Error('auth: address needed when 3ID provider is not used');

              case 12:
                _context6.next = 14;
                return ThreeId.getIdFromEthAddress(opts.address, this._provider, this._ipfs, this.replicator._orbitdb.keystore, opts);

              case 14:
                this._3id = _context6.sent;
                _context6.next = 17;
                return this._load(Object.assign(opts, {
                  spaces: spaces
                }));

              case 17:
                _context6.next = 23;
                break;

              case 19:
                if (!(this._provider.threeIdConnect && this._provider.migration && !opts.address)) {
                  _context6.next = 21;
                  break;
                }

                throw new Error('auth: address needed when 3ID provider not given');

              case 21:
                _context6.next = 23;
                return this._3id.authenticate(spaces, {
                  address: opts.address
                });

              case 23:
                _context6.next = 25;
                return this.linkAddress();

              case 25:
                _context6.next = 27;
                return Promise.all(spaces.map( /*#__PURE__*/function () {
                  var _ref3 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee5(space) {
                    return _regenerator["default"].wrap(function _callee5$(_context5) {
                      while (1) {
                        switch (_context5.prev = _context5.next) {
                          case 0:
                            _context5.next = 2;
                            return _this3.openSpace(space);

                          case 2:
                          case "end":
                            return _context5.stop();
                        }
                      }
                    }, _callee5);
                  }));

                  return function (_x3) {
                    return _ref3.apply(this, arguments);
                  };
                }()));

              case 27:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function auth() {
        return _auth.apply(this, arguments);
      }

      return auth;
    }()
    /**
     * Opens the 3Box associated with the given address
     *
     * @param     {String}            address                 An ethereum address
     * @param     {provider}          provider                An ethereum or 3ID provider
     * @param     {Object}            opts                    Optional parameters
     * @param     {Function}          opts.consentCallback    A function that will be called when the user has consented to opening the box
     * @param     {String}            opts.pinningNode        A string with an ipfs multi-address to a 3box pinning node
     * @param     {Object}            opts.ipfs               A js-ipfs ipfs object
     * @param     {String}            opts.addressServer      URL of the Address Server
     * @param     {String}            opts.contentSignature   A signature, provided by a client of 3box using the private keys associated with the given address, of the 3box consent message
     * @return    {Box}                                       the 3Box instance for the given address
     */

  }, {
    key: "openSpace",

    /**
     * Opens the space with the given name in the users 3Box
     *
     * @param     {String}            name                    The name of the space
     * @param     {Object}            opts                    Optional parameters
     * @param     {Function}          opts.consentCallback    A function that will be called when the user has consented to opening the box
     * @param     {Function}          opts.onSyncDone         A function that will be called when the space has finished syncing with the pinning node
     * @return    {Space}                                     the Space instance for the given space name
     */
    value: function () {
      var _openSpace = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee7(name) {
        var opts,
            _args7 = arguments;
        return _regenerator["default"].wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                opts = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : {};
                opts = Object.assign(opts, {
                  address: this._3idEthAddress
                });

                if (!name.includes('.')) {
                  _context7.next = 4;
                  break;
                }

                throw new Error('Invalid name: character "." not allowed');

              case 4:
                if (this._3id) {
                  _context7.next = 6;
                  break;
                }

                throw new Error('openSpace: auth required');

              case 6:
                if (!this.spaces[name]) {
                  this.spaces[name] = new Space(name, this.replicator);
                }

                if (this.spaces[name].isOpen) {
                  _context7.next = 23;
                  break;
                }

                _context7.prev = 8;
                _context7.next = 11;
                return this.spaces[name].open(this._3id, opts);

              case 11:
                _context7.next = 21;
                break;

              case 13:
                _context7.prev = 13;
                _context7.t0 = _context7["catch"](8);
                delete this.spaces[name];

                if (!_context7.t0.message.includes('User denied message signature.')) {
                  _context7.next = 20;
                  break;
                }

                throw new Error('User denied space consent.');

              case 20:
                throw new Error('An error occurred while opening space: ', _context7.t0);

              case 21:
                _context7.next = 24;
                break;

              case 23:
                if (opts.onSyncDone) {
                  // since the space is already open we can call onSyncDone directly
                  opts.onSyncDone();
                }

              case 24:
                return _context7.abrupt("return", this.spaces[name]);

              case 25:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this, [[8, 13]]);
      }));

      function openSpace(_x4) {
        return _openSpace.apply(this, arguments);
      }

      return openSpace;
    }()
    /**
     * Open a thread. Use this to start receiving updates
     *
     * @param     {String}    space                   The name of the space for this thread
     * @param     {String}    name                    The name of the thread
     * @param     {Object}    opts                    Optional parameters
     * @param     {String}    opts.firstModerator     DID of first moderator of a thread, by default, user is first moderator
     * @param     {Boolean}   opts.members            join a members only thread, which only members can post in, defaults to open thread
     * @param     {Boolean}   opts.noAutoSub          Disable auto subscription to the thread when posting to it (default false)
     * @param     {Boolean}   opts.ghost              Enable ephemeral messaging via Ghost Thread
     * @param     {Number}    opts.ghostBacklogLimit  The number of posts to maintain in the ghost backlog
     * @param     {Array<Function>} opts.ghostFilters Array of functions for filtering messages
     *
     * @return    {Thread}                  An instance of the thread class for the joined thread
     */

  }, {
    key: "openThread",
    value: function () {
      var _openThread = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee8(space, name, opts) {
        var options;
        return _regenerator["default"].wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                if (!this.spaces[space]) {
                  this.spaces[space] = new Space(space, this.replicator);
                }

                if (this._ghostPinbot) {
                  options = opts || {};
                  options.ghostPinbot = this._ghostPinbot;
                }

                return _context8.abrupt("return", this.spaces[space].joinThread(name, opts));

              case 3:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function openThread(_x5, _x6, _x7) {
        return _openThread.apply(this, arguments);
      }

      return openThread;
    }()
    /**
     * Sets the callback function that will be called once when the box is fully synced.
     *
     * @param     {Function}      syncDone        The function that will be called
     * @return    {Promise}                       A promise that is fulfilled when the box is syned
     */

  }, {
    key: "onSyncDone",
    value: function () {
      var _onSyncDone = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee9(syncDone) {
        return _regenerator["default"].wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this.syncDone;

              case 2:
                syncDone();

              case 3:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function onSyncDone(_x8) {
        return _onSyncDone.apply(this, arguments);
      }

      return onSyncDone;
    }()
  }, {
    key: "_publishRootStore",
    value: function () {
      var _publishRootStore2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee11(rootStoreAddress) {
        var _this4 = this;

        var addressToken, publish;
        return _regenerator["default"].wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                _context11.next = 2;
                return this._3id.signJWT({
                  rootStoreAddress: rootStoreAddress
                });

              case 2:
                addressToken = _context11.sent;

                // Store odbAddress on 3box-address-server
                publish = /*#__PURE__*/function () {
                  var _ref4 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee10(token) {
                    return _regenerator["default"].wrap(function _callee10$(_context10) {
                      while (1) {
                        switch (_context10.prev = _context10.next) {
                          case 0:
                            _context10.prev = 0;
                            _context10.next = 3;
                            return utils.fetchJson(_this4._serverUrl + '/odbAddress', {
                              address_token: token
                            });

                          case 3:
                            _context10.next = 14;
                            break;

                          case 5:
                            _context10.prev = 5;
                            _context10.t0 = _context10["catch"](0);

                            if (!(_context10.t0.message === 'Invalid JWT')) {
                              _context10.next = 12;
                              break;
                            }

                            _context10.next = 10;
                            return new Promise(function (resolve) {
                              return setTimeout(resolve, 300);
                            });

                          case 10:
                            _context10.next = 12;
                            return publish(token);

                          case 12:
                            if (_context10.t0.statusCode) {
                              _context10.next = 14;
                              break;
                            }

                            throw new Error(_context10.t0);

                          case 14:
                          case "end":
                            return _context10.stop();
                        }
                      }
                    }, _callee10, null, [[0, 5]]);
                  }));

                  return function publish(_x10) {
                    return _ref4.apply(this, arguments);
                  };
                }();

                _context11.next = 6;
                return publish(addressToken);

              case 6:
                return _context11.abrupt("return", true);

              case 7:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function _publishRootStore(_x9) {
        return _publishRootStore2.apply(this, arguments);
      }

      return _publishRootStore;
    }()
  }, {
    key: "_getLinkedData",
    value: function () {
      var _getLinkedData2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee12(ethereumAddress) {
        var _yield$utils$fetchJso, rootStoreAddress, did;

        return _regenerator["default"].wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.prev = 0;
                _context12.next = 3;
                return utils.fetchJson("".concat(this._serverUrl, "/odbAddress/").concat(ethereumAddress));

              case 3:
                _yield$utils$fetchJso = _context12.sent.data;
                rootStoreAddress = _yield$utils$fetchJso.rootStoreAddress;
                did = _yield$utils$fetchJso.did;
                return _context12.abrupt("return", {
                  rootStoreAddress: rootStoreAddress,
                  did: did
                });

              case 9:
                _context12.prev = 9;
                _context12.t0 = _context12["catch"](0);

                if (!(_context12.t0.statusCode === 404)) {
                  _context12.next = 13;
                  break;
                }

                return _context12.abrupt("return", {});

              case 13:
                throw new Error('Error while getting rootstore', _context12.t0);

              case 14:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this, [[0, 9]]);
      }));

      function _getLinkedData(_x11) {
        return _getLinkedData2.apply(this, arguments);
      }

      return _getLinkedData;
    }()
    /**
     * @property {String} DID        the DID of the user
     */

  }, {
    key: "linkAddress",

    /**
     * Creates a proof that links an ethereum address to the 3Box account of the user. If given proof, it will simply be added to the root store.
     *
     * @param     {Object}    [link]                         Optional link object with type or proof
     * @param     {Object}    [link.proof]                   Proof object, should follow [spec](https://github.com/3box/3box/blob/master/3IPs/3ip-5.md)
     */
    value: function () {
      var _linkAddress = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee13() {
        var link,
            _args13 = arguments;
        return _regenerator["default"].wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                link = _args13.length > 0 && _args13[0] !== undefined ? _args13[0] : {};

                if (this._3id) {
                  _context13.next = 3;
                  break;
                }

                throw new Error('linkAddress: auth required');

              case 3:
                if (!link.proof) {
                  _context13.next = 8;
                  break;
                }

                _context13.next = 6;
                return this._writeAddressLink(link.proof);

              case 6:
                _context13.next = 10;
                break;

              case 8:
                _context13.next = 10;
                return this._linkProfile();

              case 10:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function linkAddress() {
        return _linkAddress.apply(this, arguments);
      }

      return linkAddress;
    }()
    /**
     * Remove given address link, returns true if successful
     *
     * @param     {String}   address      address that is linked
     */

  }, {
    key: "removeAddressLink",
    value: function () {
      var _removeAddressLink = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee14(address) {
        var linkExist, payload, oneHour, deleteToken;
        return _regenerator["default"].wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                if (this._3id) {
                  _context14.next = 2;
                  break;
                }

                throw new Error('removeAddressLink: auth required');

              case 2:
                address = address.toLowerCase();
                _context14.next = 5;
                return this.isAddressLinked({
                  address: address
                });

              case 5:
                linkExist = _context14.sent;

                if (linkExist) {
                  _context14.next = 8;
                  break;
                }

                throw new Error('removeAddressLink: link for given address does not exist');

              case 8:
                payload = {
                  address: address,
                  type: 'delete-address-link'
                };
                oneHour = 60 * 60;
                _context14.next = 12;
                return this._3id.signJWT(payload, {
                  expiresIn: oneHour
                });

              case 12:
                deleteToken = _context14.sent;
                _context14.prev = 13;
                _context14.next = 16;
                return utils.fetchJson(this._serverUrl + '/linkdelete', {
                  delete_token: deleteToken
                });

              case 16:
                _context14.next = 22;
                break;

              case 18:
                _context14.prev = 18;
                _context14.t0 = _context14["catch"](13);

                if (_context14.t0.statusCode) {
                  _context14.next = 22;
                  break;
                }

                throw new Error(_context14.t0);

              case 22:
                _context14.next = 24;
                return this._deleteAddressLink(address);

              case 24:
                return _context14.abrupt("return", true);

              case 25:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this, [[13, 18]]);
      }));

      function removeAddressLink(_x12) {
        return _removeAddressLink.apply(this, arguments);
      }

      return removeAddressLink;
    }()
    /**
     * Checks if there is a proof that links an external account to the 3Box account of the user. If not params given and any link exists, returns true
     *
     * @param     {Object}    [query]            Optional object with address and/or type.
     * @param     {String}    [query.type]       Does the given type of link exist
     * @param     {String}    [query.address]    Is the given adressed linked
     */

  }, {
    key: "isAddressLinked",
    value: function () {
      var _isAddressLinked = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee15() {
        var query,
            links,
            linksQuery,
            _args15 = arguments;
        return _regenerator["default"].wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                query = _args15.length > 0 && _args15[0] !== undefined ? _args15[0] : {};

                if (this._3id) {
                  _context15.next = 3;
                  break;
                }

                throw new Error('isAddressLinked: auth required');

              case 3:
                if (query.address) query.address = query.address.toLowerCase();
                _context15.next = 6;
                return this._readAddressLinks();

              case 6:
                links = _context15.sent;
                linksQuery = links.find(function (link) {
                  var res = query.address ? link.address.toLowerCase() === query.address : true;
                  return query.type ? res && link.type === query.type : res;
                });
                return _context15.abrupt("return", Boolean(linksQuery));

              case 9:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function isAddressLinked() {
        return _isAddressLinked.apply(this, arguments);
      }

      return isAddressLinked;
    }()
    /**
     * Lists address links associated with this 3Box
     *
     * @return    {Array}                        An array of link objects
     */

  }, {
    key: "listAddressLinks",
    value: function () {
      var _listAddressLinks = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee16() {
        var entries;
        return _regenerator["default"].wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                if (this._3id) {
                  _context16.next = 2;
                  break;
                }

                throw new Error('listAddressLinks: auth required');

              case 2:
                _context16.next = 4;
                return this._readAddressLinks();

              case 4:
                entries = _context16.sent;
                return _context16.abrupt("return", entries.reduce(function (list, entry) {
                  var item = Object.assign({}, entry);
                  item.linkId = item.entry.hash;
                  delete item.entry;
                  list.push(item);
                  return list;
                }, []));

              case 6:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function listAddressLinks() {
        return _listAddressLinks.apply(this, arguments);
      }

      return listAddressLinks;
    }()
  }, {
    key: "_writeAddressLink",
    value: function () {
      var _writeAddressLink2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee17(proof) {
        var validProof;
        return _regenerator["default"].wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                _context17.next = 2;
                return validateLink(proof);

              case 2:
                validProof = _context17.sent;

                if (validProof) {
                  _context17.next = 5;
                  break;
                }

                throw new Error('tried to write invalid link proof', proof);

              case 5:
                _context17.next = 7;
                return this.isAddressLinked({
                  address: validProof.address
                });

              case 7:
                if (!_context17.sent) {
                  _context17.next = 9;
                  break;
                }

                return _context17.abrupt("return", true);

              case 9:
                _context17.next = 11;
                return this._writeRootstoreEntry(Replicator.entryTypes.ADDRESS_LINK, proof);

              case 11:
                _context17.next = 13;
                return utils.fetchJson(this._serverUrl + '/link', proof);

              case 13:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function _writeAddressLink(_x13) {
        return _writeAddressLink2.apply(this, arguments);
      }

      return _writeAddressLink;
    }()
  }, {
    key: "_linkProfile",
    value: function () {
      var _linkProfile2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee18() {
        var address, proof, proofdid, issuer, jwt;
        return _regenerator["default"].wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                _context18.next = 2;
                return this._3id.getAddress();

              case 2:
                address = _context18.sent;
                _context18.next = 5;
                return this._readAddressLink(address);

              case 5:
                proof = _context18.sent;

                if (proof) {
                  _context18.next = 27;
                  break;
                }

                if (this._provider.is3idProvider) {
                  _context18.next = 25;
                  break;
                }

                _context18.prev = 8;
                _context18.next = 11;
                return createLink(this._3id.DID, address, this._provider);

              case 11:
                proof = _context18.sent;
                _context18.next = 17;
                break;

              case 14:
                _context18.prev = 14;
                _context18.t0 = _context18["catch"](8);
                throw new Error('Link consent message must be signed before adding data, to link address to store', _context18.t0);

              case 17:
                _context18.prev = 17;
                _context18.next = 20;
                return this._writeAddressLink(proof);

              case 20:
                _context18.next = 25;
                break;

              case 22:
                _context18.prev = 22;
                _context18.t1 = _context18["catch"](17);
                throw new Error('An error occured while publishing link:', _context18.t1);

              case 25:
                _context18.next = 37;
                break;

              case 27:
                if (this.hasPublishedLink[proof.signature]) {
                  _context18.next = 37;
                  break;
                }

                // Don't want to publish on every call to _linkProfile
                this.hasPublishedLink[proof.signature] = true;
                _context18.prev = 29;
                _context18.next = 32;
                return utils.fetchJson(this._serverUrl + '/link', proof);

              case 32:
                _context18.next = 37;
                break;

              case 34:
                _context18.prev = 34;
                _context18.t2 = _context18["catch"](29);
                throw new Error('An error occured while publishing link:', _context18.t2);

              case 37:
                _context18.next = 39;
                return this["public"].get('proof_did');

              case 39:
                proofdid = _context18.sent;

                if (!proofdid) {
                  _context18.next = 52;
                  break;
                }

                // if prior muport, re publish with 3id including muport
                issuer = didJWT.decodeJWT(proofdid).payload.iss;

                if (!issuer.includes('muport')) {
                  _context18.next = 50;
                  break;
                }

                jwt = {
                  muport: proofdid
                };
                _context18.t3 = this["public"];
                _context18.next = 47;
                return this._3id.signJWT(jwt);

              case 47:
                _context18.t4 = _context18.sent;
                _context18.next = 50;
                return _context18.t3.set.call(_context18.t3, 'proof_did', _context18.t4);

              case 50:
                _context18.next = 58;
                break;

              case 52:
                _context18.t5 = this["public"];
                _context18.next = 55;
                return this._3id.signJWT();

              case 55:
                _context18.t6 = _context18.sent;
                _context18.next = 58;
                return _context18.t5.set.call(_context18.t5, 'proof_did', _context18.t6);

              case 58:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this, [[8, 14], [17, 22], [29, 34]]);
      }));

      function _linkProfile() {
        return _linkProfile2.apply(this, arguments);
      }

      return _linkProfile;
    }()
  }, {
    key: "_writeRootstoreEntry",
    value: function () {
      var _writeRootstoreEntry2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee20(type, payload) {
        var _this5 = this;

        var cid, entryExist, entry, prev;
        return _regenerator["default"].wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                _context20.next = 2;
                return this._ipfs.dag.put(payload);

              case 2:
                cid = _context20.sent.toBaseEncodedString();
                _context20.next = 5;
                return this._ipfs.pin.add(cid);

              case 5:
                _context20.next = 7;
                return this._typeCIDExists(type, cid);

              case 7:
                entryExist = _context20.sent;

                if (!entryExist) {
                  _context20.next = 10;
                  break;
                }

                return _context20.abrupt("return");

              case 10:
                entry = {
                  type: type,
                  data: cid
                }; // the below code prevents multiple simultaneous writes,
                // which orbitdb doesn't support

                prev = this._rootstoreQueue;
                this._rootstoreQueue = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee19() {
                  return _regenerator["default"].wrap(function _callee19$(_context19) {
                    while (1) {
                      switch (_context19.prev = _context19.next) {
                        case 0:
                          if (!prev) {
                            _context19.next = 3;
                            break;
                          }

                          _context19.next = 3;
                          return prev;

                        case 3:
                          _context19.next = 5;
                          return _this5.replicator.rootstore.add(entry);

                        case 5:
                        case "end":
                          return _context19.stop();
                      }
                    }
                  }, _callee19);
                }))();

              case 13:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function _writeRootstoreEntry(_x14, _x15) {
        return _writeRootstoreEntry2.apply(this, arguments);
      }

      return _writeRootstoreEntry;
    }()
  }, {
    key: "_typeCIDExists",
    value: function () {
      var _typeCIDExists2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee21(type, cid) {
        var entries, typeEntries;
        return _regenerator["default"].wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                _context21.next = 2;
                return this.replicator.rootstore.iterator({
                  limit: -1
                }).collect();

              case 2:
                entries = _context21.sent;
                typeEntries = entries.filter(function (e) {
                  return e.payload.value.type === type;
                });
                return _context21.abrupt("return", Boolean(typeEntries.find(function (entry) {
                  return entry.data === cid;
                })));

              case 5:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));

      function _typeCIDExists(_x16, _x17) {
        return _typeCIDExists2.apply(this, arguments);
      }

      return _typeCIDExists;
    }()
  }, {
    key: "_deleteAddressLink",
    value: function () {
      var _deleteAddressLink2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee22(address) {
        var link;
        return _regenerator["default"].wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                address = address.toLowerCase();
                _context22.next = 3;
                return this._readAddressLink(address);

              case 3:
                link = _context22.sent;

                if (link) {
                  _context22.next = 6;
                  break;
                }

                throw new Error('_deleteAddressLink: link for given address does not exist');

              case 6:
                return _context22.abrupt("return", this.replicator.rootstore.remove(link.entry.hash));

              case 7:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));

      function _deleteAddressLink(_x18) {
        return _deleteAddressLink2.apply(this, arguments);
      }

      return _deleteAddressLink;
    }()
  }, {
    key: "_readAddressLinks",
    value: function () {
      var _readAddressLinks2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee23() {
        var links, allLinks;
        return _regenerator["default"].wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                _context23.next = 2;
                return this.replicator.getAddressLinks();

              case 2:
                links = _context23.sent;
                _context23.next = 5;
                return Promise.all(links.map(validateLink));

              case 5:
                allLinks = _context23.sent;
                return _context23.abrupt("return", allLinks.filter(Boolean));

              case 7:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      function _readAddressLinks() {
        return _readAddressLinks2.apply(this, arguments);
      }

      return _readAddressLinks;
    }()
  }, {
    key: "_readAddressLink",
    value: function () {
      var _readAddressLink2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee24(address) {
        var links;
        return _regenerator["default"].wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                address = address.toLowerCase();
                _context24.next = 3;
                return this._readAddressLinks();

              case 3:
                links = _context24.sent;
                return _context24.abrupt("return", links.find(function (link) {
                  return link.address.toLowerCase() === address;
                }));

              case 5:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this);
      }));

      function _readAddressLink(_x19) {
        return _readAddressLink2.apply(this, arguments);
      }

      return _readAddressLink;
    }()
  }, {
    key: "close",
    value: function () {
      var _close = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee25() {
        return _regenerator["default"].wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                if (this._3id) {
                  _context25.next = 2;
                  break;
                }

                throw new Error('close: auth required');

              case 2:
                _context25.next = 4;
                return this._3id.stopUpdatePolling();

              case 4:
                if (this.ghostPinbotKeepAliveHandle) {
                  clearInterval(this.ghostPinbotKeepAliveHandle);
                }

                _context25.next = 7;
                return this.replicator.stop();

              case 7:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25, this);
      }));

      function close() {
        return _close.apply(this, arguments);
      }

      return close;
    }()
    /**
     * Closes the 3box instance and clears local cache. If you call this,
     * users will need to sign a consent message to log in the next time
     * you call openBox.
     */

  }, {
    key: "logout",
    value: function () {
      var _logout = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee26() {
        return _regenerator["default"].wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                if (this._3id) {
                  _context26.next = 2;
                  break;
                }

                throw new Error('logout: auth required');

              case 2:
                _context26.next = 4;
                return this.close();

              case 4:
                this._3id.logout();

                delete this._3idEthAddress;
                delete this.replicator;
                delete this._3id;
                this["public"] = null;
                this["private"] = null;
                this.spaces = {};
                this.syncDone = null;
                this.hasPublishedLink = {};
                _context26.next = 15;
                return this._init(this._opts);

              case 15:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26, this);
      }));

      function logout() {
        return _logout.apply(this, arguments);
      }

      return logout;
    }()
    /**
     * Check if the given address is logged in
     *
     * @param     {String}    address                 An ethereum address
     * @return    {Boolean}                           true if the user is logged in
     */

  }, {
    key: "DID",
    get: function get() {
      if (!this._3id) throw new Error('DID: auth required');
      return this._3id.DID;
    }
  }], [{
    key: "create",
    value: function () {
      var _create = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee27(provider) {
        var opts,
            ipfs,
            box,
            _args27 = arguments;
        return _regenerator["default"].wrap(function _callee27$(_context27) {
          while (1) {
            switch (_context27.prev = _context27.next) {
              case 0:
                opts = _args27.length > 1 && _args27[1] !== undefined ? _args27[1] : {};

                if (!(opts.supportCheck !== false && browserHuh)) {
                  _context27.next = 4;
                  break;
                }

                _context27.next = 4;
                return this._supportAlert();

              case 4:
                opts.iframeCache = typeof opts.iframeCache === 'boolean' ? opts.iframeCache : true;
                _context27.next = 7;
                return Box.getIPFS(opts);

              case 7:
                ipfs = _context27.sent;
                box = new Box(provider, ipfs, opts);
                _context27.next = 11;
                return box._setProvider(provider);

              case 11:
                _context27.next = 13;
                return box._init(opts);

              case 13:
                return _context27.abrupt("return", box);

              case 14:
              case "end":
                return _context27.stop();
            }
          }
        }, _callee27, this);
      }));

      function create(_x20) {
        return _create.apply(this, arguments);
      }

      return create;
    }()
  }, {
    key: "_supportAlert",
    value: function () {
      var _supportAlert2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee28() {
        var supported;
        return _regenerator["default"].wrap(function _callee28$(_context28) {
          while (1) {
            switch (_context28.prev = _context28.next) {
              case 0:
                _context28.next = 2;
                return this.supported();

              case 2:
                supported = _context28.sent;
                if (!supported) window.alert(supportAlert);

              case 4:
              case "end":
                return _context28.stop();
            }
          }
        }, _callee28, this);
      }));

      function _supportAlert() {
        return _supportAlert2.apply(this, arguments);
      }

      return _supportAlert;
    }()
    /**
     * Determines if this browser environment supports 3boxjs and ipfs.
     *
     * @return    {Boolean}
     */

  }, {
    key: "supported",
    value: function () {
      var _supported = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee29() {
        return _regenerator["default"].wrap(function _callee29$(_context29) {
          while (1) {
            switch (_context29.prev = _context29.next) {
              case 0:
                return _context29.abrupt("return", new Promise(function (resolve, reject) {
                  if (!browserHuh) throw new Error('Supported only detects browser feature support');
                  window.Modernizr.on('indexeddb', resolve);
                }));

              case 1:
              case "end":
                return _context29.stop();
            }
          }
        }, _callee29);
      }));

      function supported() {
        return _supported.apply(this, arguments);
      }

      return supported;
    }()
  }, {
    key: "get3idConnectProvider",
    value: function get3idConnectProvider() {
      throw new Error('3idConnectProvider function is no longer supported, initialize 3box as you did before 3idConnectProvider by passing a provider to Box.create or box.auth, and 3box will create a 3idConnectProvider in the background using your given provider - https://medium.com/3box/introducing-3id-connect-531af4f84d3f');
    }
  }, {
    key: "openBox",
    value: function () {
      var _openBox = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee30(address, provider) {
        var opts,
            box,
            _args30 = arguments;
        return _regenerator["default"].wrap(function _callee30$(_context30) {
          while (1) {
            switch (_context30.prev = _context30.next) {
              case 0:
                opts = _args30.length > 2 && _args30[2] !== undefined ? _args30[2] : {};
                opts = Object.assign(opts, {
                  address: address
                });
                _context30.next = 4;
                return Box.create(provider, opts);

              case 4:
                box = _context30.sent;
                _context30.next = 7;
                return box.auth([], opts);

              case 7:
                return _context30.abrupt("return", box);

              case 8:
              case "end":
                return _context30.stop();
            }
          }
        }, _callee30);
      }));

      function openBox(_x21, _x22) {
        return _openBox.apply(this, arguments);
      }

      return openBox;
    }()
  }, {
    key: "isLoggedIn",
    value: function isLoggedIn(address) {
      console.warn('Box.isLoggedIn: function no longer supported, simply call auth and it will not prompt user again if they have already authenticated');
      return ThreeId.isLoggedIn(address);
    }
    /**
     * Instanciate ipfs used by 3Box without calling openBox.
     *
     * @return    {IPFS}                           the ipfs instance
     */

  }, {
    key: "getIPFS",
    value: function () {
      var _getIPFS = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee31() {
        var opts,
            ipfs,
            pinningNode,
            _args31 = arguments;
        return _regenerator["default"].wrap(function _callee31$(_context31) {
          while (1) {
            switch (_context31.prev = _context31.next) {
              case 0:
                opts = _args31.length > 0 && _args31[0] !== undefined ? _args31[0] : {};

                if (browserHuh) {
                  globalIPFS = window.globalIPFS;
                  globalIPFSPromise = window.globalIPFSPromise;
                }

                if (!globalIPFS && !globalIPFSPromise) {
                  globalIPFSPromise = initIPFS(opts.ipfs, opts.iframeStore, opts.ipfsOptions, opts.iframeCache);
                }

                if (browserHuh) window.globalIPFSPromise = globalIPFSPromise;

                if (globalIPFS) {
                  _context31.next = 8;
                  break;
                }

                _context31.next = 7;
                return globalIPFSPromise;

              case 7:
                globalIPFS = _context31.sent;

              case 8:
                if (browserHuh) window.globalIPFS = globalIPFS;
                ipfs = globalIPFS;
                pinningNode = opts.pinningNode || PINNING_NODE;
                ipfs.swarm.connect(pinningNode);

                if (opts.ghostPinbot) {
                  ipfs.swarm.connect(opts.ghostPinbot);
                }

                if (browserHuh && ipfs.libp2p && !opts.disableRendezvous) {
                  ipfs.libp2p.transportManager.listen(multiaddr(RENDEZVOUS_ADDRESS))["catch"](console.warn);
                }

                return _context31.abrupt("return", ipfs);

              case 15:
              case "end":
                return _context31.stop();
            }
          }
        }, _callee31);
      }));

      function getIPFS() {
        return _getIPFS.apply(this, arguments);
      }

      return getIPFS;
    }()
  }]);
  return Box;
}(BoxApi);

function initIPFSRepo(_x23) {
  return _initIPFSRepo.apply(this, arguments);
}

function _initIPFSRepo() {
  _initIPFSRepo = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee32(iframeCache) {
    var repoOpts, ipfsRootPath, sessionID, levelInstance, ipfsDatastorePath, levelDatastore, cacheSupported, repo;
    return _regenerator["default"].wrap(function _callee32$(_context32) {
      while (1) {
        switch (_context32.prev = _context32.next) {
          case 0:
            repoOpts = {};

            if (!(typeof window !== 'undefined' && window.indexedDB)) {
              _context32.next = 13;
              break;
            }

            sessionID = utils.randInt(10000);
            ipfsRootPath = 'ipfs/root/' + sessionID;
            levelInstance = new LevelStore(ipfsRootPath);
            ipfsDatastorePath = 'ipfs/datastore'; // path name level-js-ipfs/datastore

            levelDatastore = new LevelStore(ipfsDatastorePath);
            repoOpts = {
              storageBackends: {
                root: function root() {
                  return levelInstance;
                },
                datastore: function datastore() {
                  return levelDatastore;
                }
              }
            };

            if (!(iframeCache && iframeCacheService)) {
              _context32.next = 13;
              break;
            }

            _context32.next = 11;
            return cacheSupportedPromise;

          case 11:
            cacheSupported = _context32.sent;

            if (cacheSupported) {
              repoOpts.storageBackends.blocks = iframeCacheService.getIpfsStorageProxy();
            }

          case 13:
            repo = new IPFSRepo('ipfs', repoOpts);
            return _context32.abrupt("return", {
              repo: repo,
              rootPath: ipfsRootPath
            });

          case 15:
          case "end":
            return _context32.stop();
        }
      }
    }, _callee32);
  }));
  return _initIPFSRepo.apply(this, arguments);
}

function initIPFS(_x24, _x25, _x26, _x27) {
  return _initIPFS.apply(this, arguments);
}

function _initIPFS() {
  _initIPFS = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee33(ipfs, iframeStore, ipfsOptions, iframeCache) {
    var ipfsRepo;
    return _regenerator["default"].wrap(function _callee33$(_context33) {
      while (1) {
        switch (_context33.prev = _context33.next) {
          case 0:
            if (!!ipfs && iframeCache) console.warn('Warning: Caching in iframe is true, but the given ipfs object that is being used may not be using the iframe cache');

            if (!ipfs) {
              _context33.next = 5;
              break;
            }

            return _context33.abrupt("return", ipfs);

          case 5:
            if (ipfsOptions) {
              _context33.next = 11;
              break;
            }

            if (ipfsOptions && iframeCache) console.warn('Warning: Caching in iframe is true, but received ipfs options which may not include the proper repo configuration for using the iframe cache');
            _context33.next = 9;
            return initIPFSRepo(iframeCache);

          case 9:
            ipfsRepo = _context33.sent;
            ipfsOptions = Object.assign(IPFS_OPTIONS, {
              repo: ipfsRepo.repo
            });

          case 11:
            _context33.next = 13;
            return IPFS.create(ipfsOptions);

          case 13:
            ipfs = _context33.sent;

            if (ipfsRepo && typeof window !== 'undefined' && window.indexedDB) {
              // deletes once db is closed again
              window.indexedDB.deleteDatabase(ipfsRepo.rootPath);
            }

            return _context33.abrupt("return", ipfs);

          case 16:
          case "end":
            return _context33.stop();
        }
      }
    }, _callee33);
  }));
  return _initIPFS.apply(this, arguments);
}

Box.idUtils = idUtils;
module.exports = Box;