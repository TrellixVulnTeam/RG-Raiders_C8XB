"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _didResolver = require("did-resolver");

var _nodeFetch = _interopRequireDefault(require("node-fetch"));

var INFURA = 'https://ipfs.infura.io/ipfs/';

function getResolver(ipfs) {
  function resolve(_x, _x2) {
    return _resolve.apply(this, arguments);
  }

  function _resolve() {
    _resolve = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(did, parsed) {
      var doc;
      return _regenerator["default"].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return fetchMuPortDoc(ipfs, parsed.id);

            case 2:
              doc = _context.sent;
              return _context.abrupt("return", wrapDocument(did, doc));

            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _resolve.apply(this, arguments);
  }

  return {
    'muport': resolve
  };
}

function fetchMuPortDoc(_x3, _x4) {
  return _fetchMuPortDoc.apply(this, arguments);
}

function _fetchMuPortDoc() {
  _fetchMuPortDoc = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(ipfs, ipfsHash) {
    var doc, res, data;
    return _regenerator["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.prev = 0;
            _context2.next = 3;
            return ipfs.cat(ipfsHash);

          case 3:
            res = _context2.sent;

            if (!res.next) {
              _context2.next = 10;
              break;
            }

            _context2.next = 7;
            return res.next();

          case 7:
            _context2.t0 = _context2.sent.value;
            _context2.next = 11;
            break;

          case 10:
            _context2.t0 = res;

          case 11:
            data = _context2.t0;

            if (!ipfs) {
              _context2.next = 16;
              break;
            }

            _context2.t1 = JSON.parse(data);
            _context2.next = 19;
            break;

          case 16:
            _context2.next = 18;
            return httpFetch(ipfsHash);

          case 18:
            _context2.t1 = _context2.sent;

          case 19:
            doc = _context2.t1;
            _context2.next = 24;
            break;

          case 22:
            _context2.prev = 22;
            _context2.t2 = _context2["catch"](0);

          case 24:
            if (!(!doc || doc.version !== 1 || !doc.signingKey || !doc.managementKey || !doc.asymEncryptionKey)) {
              _context2.next = 26;
              break;
            }

            throw new Error('Invalid muport did');

          case 26:
            return _context2.abrupt("return", doc);

          case 27:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[0, 22]]);
  }));
  return _fetchMuPortDoc.apply(this, arguments);
}

function httpFetch(_x5) {
  return _httpFetch.apply(this, arguments);
}

function _httpFetch() {
  _httpFetch = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(cid) {
    return _regenerator["default"].wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return (0, _nodeFetch["default"])(INFURA + cid);

          case 2:
            return _context3.abrupt("return", _context3.sent.json());

          case 3:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _httpFetch.apply(this, arguments);
}

function wrapDocument(did, muportDocument) {
  var doc = {
    "@context": "https://w3id.org/did/v1",
    "id": did,
    "publicKey": [{
      "id": did + "#signingKey",
      "type": "Secp256k1VerificationKey2018",
      "owner": did,
      "publicKeyHex": muportDocument.signingKey
    }, {
      "id": did + "#managementKey",
      "type": "Secp256k1VerificationKey2018",
      "owner": did
    }, {
      "id": did + "#encryptionKey",
      "type": "Curve25519EncryptionPublicKey",
      "owner": did,
      "publicKeyBase64": muportDocument.asymEncryptionKey
    }],
    "authentication": [{
      "type": "Secp256k1SignatureAuthentication2018",
      "publicKey": did + "#signingKey"
    }],
    "muportData": {}
  };

  if (muportDocument.managementKey.length === 42) {
    doc.publicKey[1].ethereumAddress = muportDocument.managementKey;
  } else {
    doc.publicKey[1].publicKeyHex = muportDocument.managementKey;
  }

  if (muportDocument.publicProfile) doc.uportProfile = muportDocument.publicProfile;
  if (muportDocument.symEncryptedData) doc.muportData.symEncryptedData = muportDocument.symEncryptedData;
  if (muportDocument.recoveryNetwork) doc.muportData.recoveryNetwork = muportDocument.recoveryNetwork;
  return doc;
}

module.exports = {
  getResolver: getResolver
};