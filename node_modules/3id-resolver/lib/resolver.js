"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _didJwt = require("did-jwt");

var _ipfsDidDocument = _interopRequireDefault(require("ipfs-did-document"));

var _base64url = _interopRequireDefault(require("base64url"));

var _didResolver = require("did-resolver");

var PUBKEY_IDS = ['signingKey', 'managementKey', 'encryptionKey'];
var SUB_PUBKEY_IDS = ['subSigningKey', 'subEncryptionKey'];

function validateDoc(doc) {
  var pubKeyIds = PUBKEY_IDS;

  if (!doc || !doc.publicKey || !doc.authentication) {
    throw new Error('Not a valid 3ID');
  }

  if (doc.root) {
    pubKeyIds = SUB_PUBKEY_IDS;
    if (!doc.space) throw new Error('Not a valid 3ID');
  }

  doc.publicKey.map(function (entry) {
    var id = entry.id.split('#')[1];
    if (!pubKeyIds.includes(id)) throw new Error('Not a valid 3ID');
  });
}

function encodeSection(data) {
  return _base64url["default"].encode(JSON.stringify(data));
}

function verifyProof(_x, _x2) {
  return _verifyProof.apply(this, arguments);
}

function _verifyProof() {
  _verifyProof = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(subDoc, resolver) {
    var subSigningKey, subEncryptionKey, payload, header, jwt;
    return _regenerator["default"].wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            subSigningKey = subDoc.publicKey.find(function (entry) {
              return entry.id.includes(SUB_PUBKEY_IDS[0]);
            }).publicKeyHex;
            subEncryptionKey = subDoc.publicKey.find(function (entry) {
              return entry.id.includes(SUB_PUBKEY_IDS[1]);
            }).publicKeyBase64;
            payload = encodeSection({
              iat: null,
              subSigningKey: subSigningKey,
              subEncryptionKey: subEncryptionKey,
              space: subDoc.space,
              iss: subDoc.root
            });
            header = encodeSection({
              typ: 'JWT',
              alg: subDoc.proof.alg
            });
            jwt = "".concat(header, ".").concat(payload, ".").concat(subDoc.proof.signature);
            _context3.next = 7;
            return (0, _didJwt.verifyJWT)(jwt, {
              resolver: resolver
            });

          case 7:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _verifyProof.apply(this, arguments);
}

function mergeDocuments(doc, subDoc) {
  subDoc.publicKey = doc.publicKey.concat(subDoc.publicKey);
  return subDoc;
}

function getResolver(ipfs) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      pin = _ref.pin;

  function resolve(_x3, _x4) {
    return _resolve2.apply(this, arguments);
  }

  function _resolve2() {
    _resolve2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(did, parsed) {
      var _resolve, _resolve3;

      return _regenerator["default"].wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _resolve3 = function _resolve5() {
                _resolve3 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(cid) {
                  var isRoot,
                      doc,
                      rootDoc,
                      _args = arguments;
                  return _regenerator["default"].wrap(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          isRoot = _args.length > 1 && _args[1] !== undefined ? _args[1] : false;
                          _context.prev = 1;
                          _context.next = 4;
                          return _ipfsDidDocument["default"].cidToDocument(ipfs, cid);

                        case 4:
                          doc = _context.sent;
                          validateDoc(doc);

                          if (!doc.root) {
                            _context.next = 15;
                            break;
                          }

                          if (!isRoot) {
                            _context.next = 9;
                            break;
                          }

                          throw new Error('Only one layer subDoc allowed');

                        case 9:
                          _context.next = 11;
                          return _resolve(doc.root.split(':')[2], true);

                        case 11:
                          rootDoc = _context.sent;
                          _context.next = 14;
                          return verifyProof(doc, localResolver);

                        case 14:
                          doc = mergeDocuments(rootDoc, doc);

                        case 15:
                          if (!pin) {
                            _context.next = 18;
                            break;
                          }

                          _context.next = 18;
                          return ipfs.pin.add(cid);

                        case 18:
                          _context.next = 31;
                          break;

                        case 20:
                          _context.prev = 20;
                          _context.t0 = _context["catch"](1);
                          _context.prev = 22;

                          if (!pin) {
                            _context.next = 26;
                            break;
                          }

                          _context.next = 26;
                          return ipfs.pin.rm(cid);

                        case 26:
                          _context.next = 30;
                          break;

                        case 28:
                          _context.prev = 28;
                          _context.t1 = _context["catch"](22);

                        case 30:
                          throw new Error('Invalid 3ID');

                        case 31:
                          return _context.abrupt("return", doc);

                        case 32:
                        case "end":
                          return _context.stop();
                      }
                    }
                  }, _callee, null, [[1, 20], [22, 28]]);
                }));
                return _resolve3.apply(this, arguments);
              };

              _resolve = function _resolve4(_x5) {
                return _resolve3.apply(this, arguments);
              };

              return _context2.abrupt("return", _resolve(parsed.id));

            case 3:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _resolve2.apply(this, arguments);
  }

  var resolveMethods = {
    '3': resolve
  };
  var localResolver = new _didResolver.Resolver(resolveMethods);
  return resolveMethods;
}

module.exports = {
  getResolver: getResolver
};